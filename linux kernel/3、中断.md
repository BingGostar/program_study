
//=================================================中断上半部===================================================


### 中断相关概念
```
// 中断一般分为异步中断(一般由硬件引起)和同步中断(一般由处理器本身引起)。

// 异步：硬件的电信号随机产生
   同步：由cpu控制单元产生，只有在一条指令终止执行后cpu才发出中断。比如：系统异常处理(比如运算中的除0操作)
        应用程序出现异常后，需要内核来处理
        内核调用相应的异常处理函数来处理异常
        处理完后终了应用程序或者给出message

// 把同步和异步又叫做异常和中断

// 中断和异常
    中断
        > 可屏蔽
            I/O设备发出的中断请求(IRQ)可被CPU忽略相应
        > 不可屏蔽
            不能用软件进行屏蔽，如硬件故障
    异常
        处理器探测异常，分为：
        故障（fault）、陷阱（trap）、异常终止（abort）、编程异常（programmed exception）

// IRQ
    每个能够发出中断请求的硬件设备都有一条IRQ的输出线
    所有现有的IRQ线都与一个名为可编程中断控制器(PIC)的硬件电路输入引脚相连
    1) 监视IRQ线，检查产生的信号。如果有两条以上的IRQ线产生信号，就是选择引脚编号较小的IRQ线
    2) 当一个IRQ线产生信号时：
        1) 把接收到的引发信号转换成对应向量
        2) 把这个向量放到PIC的一个I/O端口，从而允许cpu通过数据总线读取向量
        3) 把引发信号发送到cpu的INTR引脚，即产生一个中断
        4) 等待，直到cpu把这个信号写进PIC的一个I/O端口来确认它，才清空INTR线
        5) 到1)
    3) 可以禁止IRQ线

// 高级PIC(APIC)
    为了充分发挥SMP(对称多处理)体系结构的并行性，引入了更高级的PIC，又名APIC
    每个处理器包含一个本地APIC，所有的本地APIC都连接到一个外部的APIC。
    +--------+          +--------+
    |  cpu0  |          |  cpu1  |
    |  APIC  |          |  APIC  |      本地APIC
    +--------+          +--------+    
        |                   |
        |                   |
  ------+---------+---------+----------  中断控制器通信(ICC)总线
                  |
              +-------+      
              |  I/O  |
              |  APIC |   外部APIC          
              +-------+  
    
    相对于本地APIC，外部APIC起路由器的作用。
    静态分发：中断传给一个特定的cpu或一组cpu，或所有cpu
    动态分发：每个本地APIC都有一个优先级寄存器（TPR）。TPR计算当前运行进程的优先级。仲裁分配负荷。


// 中断描述符表(IDT)
    是一个系统表，它与每一个中断或异常向量相联系。每一个向量在表中有相应的中断或异常处理程序的入口地址
    每个向量由8字节组成。一共256*8字节存放IDT
    
// 参考资料
    https://www.cnblogs.com/wang_yb/archive/2013/04/19/3030345.html

```

### 中断处理
```
(1) 注册中断
    #include <linux/interrupt.h>
    int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char* name, void *dev)
    //注意：此函可能会睡眠，不能再中断上下文或其他不允许阻塞的代码中调用该函数
    > irg
        表示要分配的中断号，有些是预先设定（键盘鼠标），可以通过探测获取，可以通过编程动态确定
    > handler
        实际的中断处理程序
        typedef irqreturn_t (*irq_handler_t)(int, void*)
    > flags
        表示中断处理标志
        IRQF_DISABLED: 设置后表示禁止其他中断，很野蛮地行为
        TRQF_SAMPLE_RANDOM: 表明这个设备对内核熵池有贡献
        IRQF_TIMER: 表明为系统定时器中断处理而准备
        IRQF_SHARED: 可以使多个中断程序共享一个中断线
    > name
        表示中断相关设备的ASCII文本，比如pc键盘中断对应的'keyboard',以便与用户进行通信，这些会被/proc/irq和/proc/interrupts文件使用
    > dev
        用于共享中断线，多个中断程序共享一个中断线时(共用一个中断号)，依靠dev来区别各个中断程序
    > 返回值
        执行成功：0 执行失败：非0

(2) 释放中断
    void free_irq(unsigned int irq, void* dev)
    > 如果不是共享中断线，则直接删除irq对应的中断线。
    > 如果是共享中断线，则判断此中断处理程序是否中断线上的最后一个中断处理程序，
        > 是最后一个中断处理程序 -> 删除中断线和中断处理程序
        > 不是最后一个中断处理程序 -> 删除中断处理程序

(3) 中断处理程序
    static irqreturn_t handler(int irq, void* dev) 
    > irq
        中断处理程序(即request_irq()中handler)关联的中断号
    > dev
        与request_irq()中的dev一样，表示一个设备的结构体    
    > irqreturn_t
        执行成功：IRQ_HANDLED  执行失败：IRQ_NONE

(4) 共享中断处理程序
    > flags必须是IRQF_SHARED
    > 当收到中断信号时，会依次调用注册的函数
    > 中断处理程序区分他的设备是否产生了中断，需要硬件和软件的支持
    > 注册条件：中断线当前未被注册或者被注册的中断都是IRQF_SHARED
```

### 中断API
```
local_irq_disable()	禁止本地中断传递
local_irq_enable()	激活本地中断传递
local_irq_save()	保存本地中断传递的当前状态，然后禁止本地中断传递
local_irq_restore()	恢复本地中断传递到给定的状态
disable_irq()	禁止给定中断线，并确保该函数返回之前在该中断线上没有处理程序在运行
disable_irq_nosync()	禁止给定中断线
enable_irq()	激活给定中断线
irqs_disabled()	如果本地中断传递被禁止，则返回非0；否则返回0
in_interrupt()	如果在中断上下文中，则返回非0；如果在进程上下文中，则返回0
in_irq()	如果当前正在执行中断处理程序，则返回非0；否则返回0
```

### 中断机制
```
https://www.cnblogs.com/wang_yb/archive/2013/04/19/3030345.html

设备产生中断，并通过中断线将中断信号送往中断控制器，如果中断没有被屏蔽则会到达CPU的INTR引脚，CPU立即停止当前工作，根据获得中断向量号从IDT中找出门描述符，并执行相关中断程序。

//处理流程
    > do_IRQ 与体系结构有关，对所接收的中断进行应答
    > handle_IRQ_event 调用中断线上所有中断处理
    > ret_from_intr 恢复寄存器，将内核恢复到中断前的状态

    硬件处理    中断控制器 -> 处理器 -> 处理器中断内核
                                            |
                    +-----------------------+
                    ↓                                是
    内核处理    do_IRQ() -> 该线上是否有中断处理程序 -----> handle_IRQ_event()
                                       |                        ↓
                                       |                运行该线的所有中断处理程序
                                       |                        |
                                       +-----------+------------+
                                                   ↓
                                             ret_from_intr()
                                                   ↓
                                          返回内核运行中断的代码          

```






//=================================================中断下半部===================================================

### 软中断相关概念
```
(1) 哪些处理放在下半部
    如果一个任务对时间十分敏感，将其放在上半部
    如果一个任务和硬件有关，将其放在上半部
    如果一个任务要保证不被其他中断打断，将其放在上半部
    其他所有任务，考虑放在下半部

(2) 流程
    注册软中断         触发软中断          执行软中断                             否  
    open_softirq ---> raise_softirq ---> do_softirq ---> 是否有未执行的中断函数 ---> 结束本次中断
                                            ↑                          ↓ 是  
                                            +-------执行相应中断函数<---+

(3) 软中断、tasklet、工作队列
    #下半部机制   上下文    复杂度                           性能   顺序执行保障
    软中断        中断     高(确保软中断的执行顺序和锁机制)    好     没有
    tasklet       中断     中(提供接口使用软中断)             中     同类型不能(不会)同时执行
    工作队列      进程     低(在进程上下文运行，类似用户程序)  差     没有(和进程上下文一样被调度)

    > 软中断的分配时静态的(即在编译时定义)，而tasklet的分配和初始化能够在执行时进行。
    > 软中断的并行
        > 软中断(即便是同一种类型的软中断)能够并发地运行在多个CPU上。因此，软中断是可重入函数并且必须明白地使用自旋锁保护其数据结构。
    > tasklet的并行
        > tasklet不必操心这些问题。由于内核对tasklet的运行进行了更加严格的控制。同样类型的tasklet总是被串行运行。
        > 换句话说就是：不能在两个CPU上同一时候执行同样类型的tasklet。可是，类型不同的tasklet能够在几个CPU上并发执行。
        > tasklet的串行化使tasklet函数不必是可重入的


```

### 软中断处理
```
(1) 注册软中断
    void open_softirq(int nr, void (*action)(struct softirq_action *))
    {
        /* softirq_vec是个struct softirq_action类型的数组 */
        softirq_vec[nr].action = action;
    }
```




















### 硬中断、软中断、异常之间的抢占关系
```
硬中断可以被另一个优先级比自己高的硬中断“中断”，不能被同级（同一种硬中断）或低级的硬中断“中断”，更不能被软中断“中断”。

软中断可以被硬中断“中断”，但是不会被另一个软中断“中断”。在一个CPU上，软中断总是串行执行。所以在单处理器上，对软中断的数据结构进行访问不需要加任何同步原语。

```