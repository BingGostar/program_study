
//=================================================中断上半部===================================================


### 中断相关概念
```
> 中断栈
    X86上中断栈就是独立于内核栈(ARM上中断栈和内核栈则是共享的)
    多处理器系统，每个处理器都会有一个独立的中断栈和软中断栈

> 类型
    中断一般分为异步中断(一般由硬件引起)和同步中断(一般由处理器本身引起)。
    把同步和异步又叫做异常和中断
    > 异步：硬件的电信号随机产生
        > 可屏蔽: I/O设备发出的中断请求(IRQ)可被CPU忽略相应
        > 不可屏蔽: 不能用软件进行屏蔽，如硬件故障
    > 同步：由cpu控制单元产生，只有在一条指令终止执行后cpu才发出中断。比如：系统异常处理(比如运算中的除0操作)
        处理器探测异常，分为：故障（fault）、陷阱（trap）、异常终止（abort）、编程异常（programmed exception）
        应用程序出现异常后，需要内核来处理
        内核调用相应的异常处理函数来处理异常
        处理完后终了应用程序或者给出message

> 中断与抢占
    禁止中断也就禁止了内核抢占
    硬中断和软中断（只要是中断上下文）执行的时候都不允许内核抢占，换句话说，中断上下文中永远不允许进程切换

> IRQ
    每个能够发出中断请求的硬件设备都有一条IRQ的输出线
    所有现有的IRQ线都与一个名为可编程中断控制器(PIC)的硬件电路输入引脚相连
    1) 监视IRQ线，检查产生的信号。如果有两条以上的IRQ线产生信号，就是选择引脚编号较小的IRQ线
    2) 当一个IRQ线产生信号时：
        1) 把接收到的引发信号转换成对应向量
        2) 把这个向量放到PIC的一个I/O端口，从而允许cpu通过数据总线读取向量
        3) 把引发信号发送到cpu的INTR引脚，即产生一个中断
        4) 等待，直到cpu把这个信号写进PIC的一个I/O端口来确认它，才清空INTR线
        5) 到1)
    3) 可以禁止IRQ线

> 高级PIC(APIC)
    为了充分发挥SMP(对称多处理)体系结构的并行性，引入了更高级的PIC，又名APIC
    每个处理器包含一个本地APIC，所有的本地APIC都连接到一个外部的APIC。
    +--------+          +--------+
    |  cpu0  |          |  cpu1  |
    |  APIC  |          |  APIC  |      本地APIC
    +--------+          +--------+    
        |                   |
        |                   |
  ------+---------+---------+----------  中断控制器通信(ICC)总线
                  |
              +-------+      
              |  I/O  |
              |  APIC |   外部APIC          
              +-------+  
    
    相对于本地APIC，外部APIC起路由器的作用。
    静态分发：中断传给一个特定的cpu或一组cpu，或所有cpu
    动态分发：每个本地APIC都有一个优先级寄存器（TPR）。TPR计算当前运行进程的优先级。仲裁分配负荷。


> 中断描述符表(IDT)
    是一个系统表，它与每一个中断或异常向量相联系。每一个向量在表中有相应的中断或异常处理程序的入口地址
    每个向量由8字节组成。一共256*8字节存放IDT
    
// 参考资料
    https://www.cnblogs.com/wang_yb/archive/2013/04/19/3030345.html

```

### 中断处理
```
(1) 注册中断
    #include <linux/interrupt.h>
    int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char* name, void *dev)
    //注意：此函可能会睡眠，不能再中断上下文或其他不允许阻塞的代码中调用该函数
    > irg
        表示要分配的中断号，有些是预先设定（键盘鼠标），可以通过探测获取，可以通过编程动态确定
    > handler
        实际的中断处理程序
        typedef irqreturn_t (*irq_handler_t)(int, void*)
    > flags
        表示中断处理标志
        IRQF_DISABLED: 设置后表示禁止其他中断，很野蛮地行为
        TRQF_SAMPLE_RANDOM: 表明这个设备对内核熵池有贡献
        IRQF_TIMER: 表明为系统定时器中断处理而准备
        IRQF_SHARED: 可以使多个中断程序共享一个中断线
    > name
        表示中断相关设备的ASCII文本，比如pc键盘中断对应的'keyboard',以便与用户进行通信，这些会被/proc/irq和/proc/interrupts文件使用
    > dev
        用于共享中断线，多个中断程序共享一个中断线时(共用一个中断号)，依靠dev来区别各个中断程序
    > 返回值
        执行成功：0 执行失败：非0

(2) 释放中断
    void free_irq(unsigned int irq, void* dev)
    > 如果不是共享中断线，则直接删除irq对应的中断线。
    > 如果是共享中断线，则判断此中断处理程序是否中断线上的最后一个中断处理程序，
        > 是最后一个中断处理程序 -> 删除中断线和中断处理程序
        > 不是最后一个中断处理程序 -> 删除中断处理程序

(3) 中断处理程序
    static irqreturn_t handler(int irq, void* dev) 
    > irq
        中断处理程序(即request_irq()中handler)关联的中断号
    > dev
        与request_irq()中的dev一样，表示一个设备的结构体    
    > irqreturn_t
        执行成功：IRQ_HANDLED  执行失败：IRQ_NONE

(4) 共享中断处理程序
    > flags必须是IRQF_SHARED
    > 当收到中断信号时，会依次调用注册的函数
    > 中断处理程序区分他的设备是否产生了中断，需要硬件和软件的支持
    > 注册条件：中断线当前未被注册或者被注册的中断都是IRQF_SHARED
```

### 中断API
```
local_irq_disable()	禁止本地中断传递
local_irq_enable()	激活本地中断传递
local_irq_save()	保存本地中断传递的当前状态，然后禁止本地中断传递
local_irq_restore()	恢复本地中断传递到给定的状态
disable_irq()	禁止给定中断线，并确保该函数返回之前在该中断线上没有处理程序在运行
disable_irq_nosync()	禁止给定中断线
enable_irq()	激活给定中断线
irqs_disabled()	如果本地中断传递被禁止，则返回非0；否则返回0
in_interrupt()	如果在中断上下文中，则返回非0；如果在进程上下文中，则返回0
in_irq()	如果当前正在执行中断处理程序，则返回非0；否则返回0
```

### 中断机制
```
https://www.cnblogs.com/wang_yb/archive/2013/04/19/3030345.html

设备产生中断，并通过中断线将中断信号送往中断控制器，如果中断没有被屏蔽则会到达CPU的INTR引脚，CPU立即停止当前工作，根据获得中断向量号从IDT中找出门描述符，并执行相关中断程序。

//处理流程
    > do_IRQ 与体系结构有关，对所接收的中断进行应答
    > handle_IRQ_event 调用中断线上所有中断处理
    > ret_from_intr 恢复寄存器，将内核恢复到中断前的状态

    硬件处理    中断控制器 -> 处理器 -> 处理器中断内核
                                            |
                    +-----------------------+
                    ↓                                是
    内核处理    do_IRQ() -> 该线上是否有中断处理程序 -----> handle_IRQ_event()
                                       |                        ↓
                                       |                运行该线的所有中断处理程序
                                       |                        |
                                       +-----------+------------+
                                                   ↓
                                             ret_from_intr()
                                                   ↓
                                          返回内核运行中断的代码          

```






//=================================================中断下半部===================================================

### 软中断相关概念
```
(1) 哪些处理放在下半部
    如果一个任务对时间十分敏感，将其放在上半部
    如果一个任务和硬件有关，将其放在上半部
    如果一个任务要保证不被其他中断打断，将其放在上半部
    其他所有任务，考虑放在下半部

(2) 流程
    注册软中断         触发软中断          执行软中断                             否  
    open_softirq ---> raise_softirq ---> do_softirq ---> 是否有未执行的中断函数 ---> 结束本次中断
                                            ↑                          ↓ 是  
                                            +-------执行相应中断函数<---+

(3) 软中断、tasklet、工作队列
    #下半部机制   上下文    复杂度                           性能   顺序执行保障                能否睡眠 工作场景
    软中断        中断     高(确保软中断的执行顺序和锁机制)    好     没有                       不能     中断上下文   
    tasklet       中断     中(提供接口使用软中断)             中     同类型不能(不会)同时执行    不能     中断上下文  
    工作队列      进程     低(在进程上下文运行，类似用户程序)  差     没有(和进程上下文一样被调度) 可以     进程上下文

    > 软中断的分配时静态的(即在编译时定义)，而tasklet的分配和初始化能够在执行时进行。
    > 软中断的并行
        > 软中断(即便是同一种类型的软中断)能够并发地运行在多个CPU上。因此，软中断是可重入函数并且必须明白地使用自旋锁保护其数据结构。
    > tasklet的并行
        > tasklet不必操心这些问题。由于内核对tasklet的运行进行了更加严格的控制。同样类型的tasklet总是被串行运行。
        > 换句话说就是：不能在两个CPU上同一时候执行同样类型的tasklet。可是，类型不同的tasklet能够在几个CPU上并发执行。
        > tasklet的串行化使tasklet函数不必是可重入的

https://blog.csdn.net/vividonly/article/details/6609053
http://blog.sae.sina.com.cn/archives/4103
https://www.cnblogs.com/tolimit/p/4495128.html
https://blog.csdn.net/droidphone/article/details/7518428
http://www.wowotech.net/irq_subsystem/soft-irq.html

```

### 软中断涉及的结构与函数
```
(1) softirq_action
    //数组元素为 softirq_action,一个元素代码一个软中断。不同的软中断号对应不同的数组的下标
    static struct softirq_action softirq_vec[32]__cacheline_aligned_in_smp;
    
    struct softirq_action {
        //软中断发生时执行软中断的处理函数
        void (*action)(struct softirq_action *); 
        //软中断的处理函数的参数指针
        void *data;
    }

    //软中断类型
    enum {
        HI_SOFTIRQ=0,          //处理高优先级的tasklet
        TIMER_SOFTIRQ,         //时钟中断相关的tasklet
        NET_TX_SOFTIRQ,        //内核把数据报文传送给网卡
        NET_RX_SOFTIRQ,        //内核从网卡接收数据报文
        BLOCK_SOFTIRQ,         //块设备的软中断
        BLOCK_IOPOLL_SOFTIRQ,  //支持IO轮询的块设备软中断
        TASKLET_SOFTIRQ,       //处理常规tasklet
        SCHED_SOFTIRQ,         //调度程序软中断
        HRTIMER_SOFTIRQ,       //高精度计时器软中断
        RCU_SOFTIRQ,           //RCU锁软中断，该软中断总是最后一个软中断
        NR_SOFTIRQS
    };

(2) irq_cpustat_t
    多个软中断可以同时在多个cpu运行，就算是同一种软中断，也有可能同时在多个cpu上运行。内核为每个cpu都管理着一个待决软中断变量（pending），它就是irq_cpustat_t
    typedef struct {
        unsigned int __softirq_pending;
    } ____cacheline_aligned irq_cpustat_t;
    > irq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned;
        内核使用local_softirq_pending()获取此CPU的__softirq_pending的值
    > __softirq_pending用于表示该CPU的哪个软中断处于挂起状态

(3) preempt_count
    该字段放在每个进程描述符的 thread_info 字段中
    preempt_count这个成员被用来判断当前进程是否可以被抢占。如果preempt_count不等于0（可能是代码调用preempt_disable显式的禁止了抢占，也可能是处于中断上下文等），说明当前不能进行抢占，如果preempt_count等于0，说明已经具备了抢占的条件
    0~7位	抢占计数器，记录显示禁用本地cpu内核抢占的次数，值为0时代表内核允许抢占。
    8~15位	软中断计数器。记录软中断被禁用的次数，0表示软中断被激活。
    16~27位	硬中断计数器。记录硬中断嵌套的层数。irq_entry()增加它的值，irq_exit()递减它的值。
    
(4) 注册软中断
    void open_softirq(int nr, void (*action)(struct softirq_action *)) {
        // softirq_vec是个struct softirq_action类型的数组
        softirq_vec[nr].action = action;
    }
    > nr(软中断类型)
    > action(软中断处理的函数指针)

(5) 触发软中断
    void raise_softirq(unsigned int nr) { //nr 被触发的中断类型
        unsigned long flags;

        local_irq_save(flags);
        raise_softirq_irqoff(nr);
        local_irq_restore(flags);
    }

(6) ksoftirqd(内核软中断守护线程)
    in_interrupt判断现在是否在中断上下文中，或者软中断是否被禁止，如果都不成立，则唤醒软中断的守护进程，在守护进程中执行软中断的回调函数
    inline void raise_softirq_irqoff(unsigned int nr) {
        ...
        if (!in_interrupt())
            wakeup_softirqd();
        ...    
    }

(7) 下半部的控制
    主要维护preempt_count来实现的
    1) 禁止下半部
    void local_bh_disable(void) {
        struct thread_info *t = current_thread_info();
        t->preempt_count += SOFTIQR_OFFSET;
    }
    2) 激活下半部
    激活下半部后，然后会检查执行软中断，检查执行调度
    void local_bh_enable(void) {
        struct thread_info *t = current_thread_info();
        t->preempt_count -= SOFTIQR_OFFSET;
        
        //是否中断嵌套和软中断挂起
        if (unlikely(!in_interrupt() && local_softirq_pending())) {
            do_softirq();  //执行软中断
        }

        preempt_count_dec();
        //检查执行调度
        preempt_check_resched(); 
    }










(3) 执行软中断
    asmlinkage void do_softirq(void) {
        __u32 pending;
        unsigned long flags;

        //判断是否在中断处理中，如果正在中断处理，就直接返回
        if (in_interrupt())
            return;

        //保存当前寄存器的值
        local_irq_save(flags);

        //取得当前已注册软中断的位图
        //待处理软中断的32位位图，如果第n位设置为1，那么第n位对应的软中断等待处理
        pending = local_softirq_pending();

        //循环处理所有已注册的软中断
        if (pending) {
            struct softirq_action *h;

            //重置位图
            set_softirq_pending(0);
            h = softirq_vec;

            //循环32位
            do {
                if (pending & 1) 
                    h->action(h);
                h++;
                pending >>= 1;
            }while(pending);
        }

        //恢复寄存器的值到中断处理前
        local_irq_restore(flags);
    }

```

### 软中断处理流程
1、流程步骤
```
(1) 硬中断执行完毕，调用irq_exit()
(2) irq_exit()中，检查该CPU是否处于嵌套中断的情况，以及是否有软中断挂起。如果没有中断嵌套(preempt_count==0)，并且有软中断挂起，那么执行软中断_do_softirq()
(3) 禁止软中断，防止软中断线程
(3) 执行软中断，设置一个软中断执行最多使用时间和循环次数(10次)，并且激活中断。
(4) 进入循环，获取CPU的__softirq_pending的副本。
(5) 执行此__softirq_pending副本中所有需要执行的软中断。
(6) 软中断执行完毕，并且禁止中断。
(7) 如果还有软中断需要执行并且循环次数没达到10次，那么跳到第(3)步(在软中断期间又发生了中断，产生了新的软中断，新的软中断记录在CPU的__softirq_pending上，而我们的__softirq_pending只是个副本)。
(8) 检查此次软中断总共使用的时间和循环次数，条件允许继续执行软中断，循环次数减一，并跳转到第4步。
```
2、重要函数
```
(1) irq_exit(中断退出)
    void irq_exit() {

        //禁止中断    
        local_irq_disable();

        //减少preempt_count的硬中断计数器
        preempt_count_sub(HARDIRQ_OFFSET);
        
        //in_interrupt()会检查preempt_count上的软中断计数器和硬中断计数器来判断是否处于中断嵌套中
        //local_softirq_pending()则会检查该CPU的__softirq_pending变量，是否有软中断挂起
        if (!in_interrupt() && local_softirq_pending())
            invoke_softirq();

        tick_irq_exit();
        rcu_irq_exit();
        trace_hardirq_exit(); /* must be last! */
    }

(2) invoke_softirq
    

```

















### 硬中断、软中断、异常之间的抢占关系
```
硬中断可以被另一个优先级比自己高的硬中断“中断”，不能被同级（同一种硬中断）或低级的硬中断“中断”，更不能被软中断“中断”。

软中断可以被硬中断“中断”，但是不会被另一个软中断“中断”。在一个CPU上，软中断总是串行执行。所以在单处理器上，对软中断的数据结构进行访问不需要加任何同步原语。

```