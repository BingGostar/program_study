### linux 信号 API
```
https://zhuanlan.zhihu.com/p/66051508
https://cloud.tencent.com/developer/column/1601
https://cloud.tencent.com/developer/article/1007500

(1) 概念
    1) 信号类似软中断
        信号与中断的相似点：
            采用了相同的异步通信方式；
            当检测出有信号或中断请求时，都暂停正在执行的程序而转去执行相应的处理程序；
            都在处理完毕后返回到原来的断点；
            对信号或中断都可进行屏蔽。
        信号与中断的区别：
            中断有优先级，而信号没有优先级，所有的信号都是平等的；
            信号处理程序是在用户态下运行的，而中断处理程序是在核心态下运行；
            中断响应是及时的，而信号响应通常都有较大的时间延迟。
    2) 分类
        信号的处理有三种方法，分别是：忽略、捕捉和默认动作，有两种信号不能被忽略（分别是 SIGKILL和SIGSTOP）
        可靠信号和不可靠信号
            那些建立在早期机制上的信号叫做不可靠信号，信号值小于SIGRTMIN(32)，主要表现为：信号可能丢失(因为不支持排队)
            信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，支持排队克服了信号可能丢失的问题
        实时信号与非实时信号
            非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号

    3) 可靠信号和不可靠信号
        > 不可靠信号：信号可能会丢失，一旦信号丢失了，进程并不能知道信号丢失
        > 可靠信号：也是阻塞信号，当发送了一个阻塞信号，并且该信号的动作时系统默认动作或捕捉该信号，如果信号从发出以后会一直保持未决的状态，直到该进程对此信号解除了阻塞，或将对此信号的动作更改为忽略。
        > 对于信号来说，信号编号小于等于31的信号都是不可靠信号，之后的信号为可卡信号，系统会根据有信号队列，将信号在递达之前进行阻塞。
        > 信号的阻塞和未决是通过信号的状态字来管理的，该状态字是按位来管理信号的状态。每个信号都有独立的阻塞字，规定了当前要阻塞地达到该进程的信号集。
        > 信号阻塞状态字（block），1代表阻塞、0代表不阻塞；信号未决状态字（pending）的1代表未决，0代表信号可以抵达了；它们都是每一个bit代表一个信号

    4) 阻塞和未决
        未决信号: 就是你的进程已经接收到了信号了，只是还没被信号处理函数处理的那些信号
        比如向进程发送SIGINT信号，内核首先会判断该进程的信号阻塞状态字是否阻塞状态，如果该信号被设置为阻塞的状态，也就是阻塞状态字对应位为1，那么信号未决状态字（pending）相应位会被内核设置为1；如果该信号阻塞解除了，也就是阻塞状态字设置为了0，那么信号未决状态字（pending）相应位会被内核设置为0，表示信号此时可以抵达了，也就是可以接收该信号了。
        阻塞状态字用户可以读写，未决状态字用户只能读，是由内核来设置表示信号递达状态的。
        这里额外说明以下，只有支持了 POSIX.1实时扩展的系统才支持排队的功能（也就阻塞状态下多次同一信号发送给某一进程可以得到多次，而不是一次）。


(2) 信号处理过程
    1) 信号---> 是否可被中断优先级上 ---->(是) 陷入内核 ---> 2)
                是否可重入函数      ---->(否) 仅设置进程表中信号域相应的位

    2) 实例:
        https://cloud.tencent.com/developer/article/1008813
        > 用户程序注册了SIGQUIT信号的处理函数sighandler。
        > 当前正在执行main函数，某条指令发生中断或异常或产生信号切换到内核态。（可重入函数）
        > 在中断处理完毕后要返回用户态的main函数之前检查到有信号SIGQUIT递达。（进程检查信号的时机）<----此时才会开始信号处理
        > 内核决定返回用户态后不是恢复main函数的上下文继续执行，而是执行sighandler函数，sighandler和main函数使用不同的堆栈空间，它们之间不存在调用和被调用的关系，是两个独立的控制流程。
        > sighandler函数返回后自动执行特殊的系统调用sigreturn再次进入内核态。
        > 如果没有新的信号要递达，这次再返回用户态就是恢复main函数的上下文继续执行了。

(3) 信号发送和睡眠
    https://cloud.tencent.com/developer/article/1007500
    1) 信号注册
        #include <signal.h>
        #define SIG_ERR ((__sighandler_t) -1)
        #define SIG_DFL ((__sighandler_t) 0)
        #define SIG_IGN ((__sighandler_t) 1)
        typedef void (*sighandler_t)(int);
        sighandler_t signal(int signum, sighandler_t handler);
        返回一个函数指针
        if (signal(SIGUSR1, sig_usr) == SIG_ERR) wrong!
        if (signal(SIGUSR1, sig_usr) == sig_usr) yes!
        经过sigaction安装的信号都能传递信息给信号处理函数，而经过signal安装的信号不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。

    2) 信号发送和睡眠函数
        #include <sys/types.h>
        #include <signal.h>
        int kill(pid_t pid, int sig);
        int raise(int sig);
        int killpg(int pgrp, int sig);
        kill函数的给进程pid发送信号。raise函数可以给当前进程发送指定的信号（自己给自己发信号）。killpg 函数可以给进程组发生信号。这三个函数都是成功返回0，错误返回-1

        #include <unistd.h>
        unsigned int alarm(unsigned int seconds);
        告诉内核在seconds秒之后给当前进程发SIGALRM信号，该信号的默认处理动作是终止当前进程
        #include <stdlib.h>
        void abort(void);
        abort函数使当前进程接收到SIGABRT信号而异常终止。就像exit函数一样，abort函数总是会成功的，所以没有返回值。

    3) pause
        使进程挂起直到一个信号被捕获(信号处理函数完成后返回)
        且调用schedule()使系统调度其他程序运行，
        在死循环中调用比完全的死循环的好处是让出cpu

(4) 阻塞和未决
    https://cloud.tencent.com/developer/article/1008811
    > 实际执行信号的处理动作称为信号递达（Delivery）
      信号从产生到递达之间的状态，称为信号未决（Pending）
      进程可以选择阻塞（Block）某个信号，SIGKILL 和 SIGSTOP 不能被阻塞
    > 信号的相关状态字
        每一位代表一个信号
        屏蔽状态字(block)、未决状态字(pending)、信号处理方法
        信号屏蔽状态字: 1代表阻塞、0代表不阻塞
        信号未决状态字: 1代表未决，0代表信号可以抵达了
        信号处理方法:   对应的某一位(信号)的处理函数
        block   pending   handler
          0       0       SIG_DEL                       未阻塞、信号没产生
          0       1       SIG_IGN                       未阻塞、信号产生（马上处理）
          1       1       void sighandler(int signo)      阻塞、信号产生处于未决状态（解除阻塞才会处理）
          1       0       void sighandler(int signo)      阻塞、信号没产生

(5) 信号集
    信号集被定义为一种数据类型：
　　typedef struct {
    　　unsigned long sig[_NSIG_WORDS]；
　　} sigset_t
    表示多个信号的数据类型
    #include <signal.h>
    //初始化由set指定的信号集，信号集里面的所有信号被清空
    int sigemptyset(sigset_t *set);
    //set指向的信号集中将包含linux支持的64种信号
    int sigfillset(sigset_t *set);

    //在使用sigset_t类型的变量之前，一定要调用sigemptyset或sigfillset做初始化，使信号集处于确定的状态

    //在set指向的信号集中加入signum信号
    int sigaddset(sigset_t *set, int signo);
    //在set指向的信号集中删除signum信号
    int sigdelset(sigset_t *set, int signo);
    //判断一个信号集的有效信号中是否包含某种信号，若包含则返回1，不包含则返回0，
    int sigismember(const sigset_t *set, int signo);

    //读取或更变进程的信号屏蔽字
    int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
    //读取当前进程的未决信号集
    int sigpending(sigset_t *set);
    

(7) 信号
    SIGHUP
        终端关闭时，该信号发送到session首进程和后台进程（&提交的）
        session首进程退出时，该信号被发送到该session中的前台进程组中的每一个进程

    SIGCHLD
        一个进程终止或停止时，此信号发送给父进程，默认是忽略此信号
        产生条件：
            子进程终止
            子进程接收到SIGSTOP信号停止时
            子进程处于停止状态，接收到SIGCONT后唤醒

    SIGTERM
        SIGTERM是杀或的killall命令发送到进程默认的信号。它会导致一过程的终止，但是SIGKILL信号不同，它可以被捕获和解释（或忽略）的过程。因此，SIGTERM类似于问一个进程终止可好，让清理文件和关闭

    实例：（SIGCHLD的应用）
        https://blog.csdn.net/isunbin/article/details/84032708
        https://blog.csdn.net/oguro/article/details/53857376
```

### sigaction
```
https://www.jianshu.com/p/f445bfeea40a

信号注册函数高级版，携带额外信息。给信号signum设置新的信号处理函数act， 同时保留该信号原有的信号处理函数oldact

> 函数
    int sigaction(int signo,const struct sigaction *restrict act, struct sigaction *restrict oact)

> 结构
    struct sigaction{
        void (*sa_handler)(int);
        void (*sa_sigaction)(int,siginfo_t *,void *);
        sigset_t sa_mask;
        int sa_flag;
    }
    > sa_handler
        信号处理程序，不接受额外数据，SIG_IGN 为忽略，SIG_DFL 为默认动作
    > SA_SIGINFO
        提供附加信息，一个指向siginfo结构的指针以及一个指向进程上下文标识符的指针,最后一个参数是一个替代的信号处理程序，当设置SA_SIGINFO时才会用他。
    > sa_mask
        字段说明了一个信号集，在调用该信号捕捉函数之前，这一信号集要加进进程的信号屏蔽字中。仅当从信号捕捉函数返回时再将进程的信号屏蔽字复位为原先值。
    > sa_flag是一个选项，主要理解两个
        SA_INTERRUPT 由此信号中断的系统调用不会自动重启
        SA_RESTART 由此信号中断的系统调用会自动重启
        SA_SIGINFO 说明了信号处理程序带有附加信息，也就是会调用 sa_sigaction 这个函数指针所指向的信号处理函数

> 实例
    void show_handler(int sig)
    {
        printf("I got signal %d\n", sig);
        int i;
        for(i = 0; i < 5; i++) {
            printf("i = %d\n", i);
            sleep(1);
        }
    }
 
int main(void)
{
    int i = 0;
    struct sigaction act, oldact;
    act.sa_handler = show_handler;

    //如果在信号SIGINT(Ctrl + c)的信号处理函数show_handler执行过程中，本进程收到信号SIGQUIT(Crt+\)，将阻塞该信号，直到show_handler执行结束才会处理接收信号SIGQUIT(pending = 0)
    sigaddset(&act.sa_mask, SIGQUIT);
    act.sa_flags = SA_RESETHAND | SA_NODEFER; //见注(2)
    //act.sa_flags = 0; //见注(3)
 
    sigaction(SIGINT, &act, &oldact);
    while(1) {
        sleep(1);
        printf("sleeping %d\n", i);
        i++;
    }
}


 
(2)    SA_NODEFER       一般情况下， 当信号处理函数运行时，内核将阻塞<该给定信号 -- SIGINT>。但是如果设置了SA_NODEFER标记， 那么在该信号处理函数运行时，内核将不会阻塞该信号。 SA_NODEFER是这个标记的正式的POSIX名字(还有一个名字SA_NOMASK，为了软件的可移植性，一般不用这个名字)    
       SA_RESETHAND    当调用信号处理函数时，将信号的处理函数重置为缺省值。 SA_RESETHAND是这个标记的正式的POSIX名字(还有一个名字SA_ONESHOT，为了软件的可移植性，一般不用这个名字)   

```