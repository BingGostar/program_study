### linux同步机制
```
同步是靠锁来解决的
https://www.zhihu.com/question/66733477/answer/246635823
https://www.zhihu.com/question/58047327/answer/155607124
https://www.cnblogs.com/wang_yb/archive/2013/05/01/3052865.html

(1) 原子操作(atomic)
    原子操作是由编译器来保证的，保证一个线程对数据的操作不会被其他线程打断。
    原子操作有2类：
        原子整数操作，有32位和64位。头文件分别为<asm/atomic.h>和<asm/atomic64.h>
        原子位操作。头文件 <asm/bitops.h>

(2) 自旋锁(spinlock)
    原子操作只能用于临界区只有一个变量的情况，实际应用中，临界区的情况要复杂的多。
    自旋锁由linux内核提供
    1) 特点
        > 当一个线程获取了锁之后，其他试图获取这个锁的线程一直在循环等待获取这个锁，直至锁重新可用。
        > 由于线程实在一直循环的获取这个锁，所以会造成CPU处理时间的浪费，因此最好将自旋锁用于能很快处理完的临界区。
        > 自旋锁是不可递归的，递归的请求同一个自旋锁会自己锁死自己
        > 自旋锁与中断
            > 禁止中断
                线程获取自旋锁之前，要禁止当前处理器上的中断（防止获取锁的线程和中断形成竞争条件）❗
                比如：当前线程获取自旋锁后，在临界区中被中断处理程序打断，中断处理程序正好也要获取这个锁，于是中断处理程序会等待当前线程释放锁，而当前线程也在等待中断执行完后再执行临界区和释放锁的代码。
            > 禁止中断下半部
                下半部处理和进程上下文共享数据时，由于下半部的处理可以抢占进程上下文的代码，所以进程上下文在对共享数据加锁前要禁止下半部的执行，解锁时再允许下半部的执行。
            > 禁止中断上半部
                中断处理程序（上半部）和下半部处理共享数据时，由于中断处理（上半部）可以抢占下半部的执行，所以下半部在对共享数据加锁前要禁止中断处理（上半部），解锁时再允许中断的执行。
            > tasklet
                同一种tasklet不能同时运行，所以同类tasklet中的共享数据不需要保护。
                不同类tasklet中共享数据时，其中一个tasklet获得锁后，不用禁止其他tasklet的执行，因为同一个处理器上不会有tasklet相互抢占的情况
                同类型或者非同类型的软中断在共享数据时，也不用禁止下半部，因为同一个处理器上不会有软中断互相抢占的情况
    2) API
        #include <asm/spinlock.h> 
        spin_lock()	            //获取指定的自旋锁
        spin_lock_irq()	        //禁止本地中断并获取指定的锁
        spin_lock_irqsave()	    //保存本地中断的当前状态，禁止本地中断，并获取指定的锁
        spin_unlock()	        //释放指定的锁
        spin_unlock_irq()	    //释放指定的锁，并激活本地中断
        spin_unlock_irqstore()	//释放指定的锁，并让本地中断恢复到以前状态
        spin_lock_init()	    //动态初始化指定的spinlock_t
        spin_trylock()	        //试图获取指定的锁，如果未获取，则返回0
        spin_is_locked()	    //如果指定的锁当前正在被获取，则返回非0，否则返回0
    3) 模型
        while (抢锁(lock) == 没抢到) {
        }
        
(3) 读写自旋锁
    1) 特点
        读写自旋锁除了和普通自旋锁一样有自旋特性以外，还有以下特点： 
        > 读锁之间是共享的, 即一个线程持有了读锁之后，其他线程也可以以读的方式持有这个锁
        > 写锁之间是互斥的, 即一个线程持有了写锁之后，其他线程不能以读或者写的方式持有这个锁
        > 读写锁之间是互斥的, 即一个线程持有了读锁之后，其他线程不能以写的方式持有这个锁
        注：读写锁要分别使用，不能混合使用，否则会造成死锁。
    2) API
        #include <asm/rwlock.h>
        read_lock()                 //获取指定的读锁
        read_lock_irq()	            //禁止本地中断并获得指定读锁
        read_lock_irqsave()	        //存储本地中断的当前状态，禁止本地中断并获得指定读锁
        read_unlock()	            //释放指定的读锁
        read_unlock_irq()	        //释放指定的读锁并激活本地中断
        read_unlock_irqrestore()	//释放指定的读锁并将本地中断恢复到指定前的状态
        write_lock()	            //获得指定的写锁
        write_lock_irq()	        //禁止本地中断并获得指定写锁
        write_lock_irqsave()	    //存储本地中断的当前状态，禁止本地中断并获得指定写锁
        write_unlock()	            //释放指定的写锁
        write_unlock_irq()	        //释放指定的写锁并激活本地中断
        write_unlock_irqrestore()	//释放指定的写锁并将本地中断恢复到指定前的状态
        write_trylock()	            //试图获得指定的写锁；如果写锁不可用，返回非0值
        rwlock_init()	            //初始化指定的rwlock_t
    3) 使用方法
        //定义读写自旋锁
        DEFINE_RWLOCK(mr_rwlock);

        read_lock(&mr_rwlock);
        /* 临界区(只读).... */
        read_unlock(&mr_rwlock);
        
        write_lock(&mr_lock);
        /* 临界区(读写)... */
        write_unlock(&mr_lock);

        //错误用法，混合使用
        /* 获取一个读锁 */
        read_lock(&mr_lock);
        /* 在获取写锁的时候，由于读写锁之间是互斥的，
        * 所以写锁会一直自旋等待读锁的释放，
        * 而此时读锁也在等待写锁获取完成后继续下面的代码。
        * 因此造成了读写锁的互相等待，形成了死锁。
        */
        write_lock(&mr_lock);
        
(4) 信号量
    1) 特点
        > 与自旋锁的区别
            信号量也是一种锁，和自旋锁不同的是，线程获取不到信号量的时候，不会像自旋锁一样循环的去试图获取锁，而是进入睡眠，直至有信号量释放出来时，才会唤醒睡眠的线程，进入临界区执行。
        > 适用于时间长的临界区
            由于使用信号量时，线程会睡眠，所以等待的过程不会占用CPU时间。所以信号量适用于等待时间较长的临界区。
            信号量消耗的CPU时间的地方在于使线程睡眠和唤醒线程，
            如果 （使线程睡眠 + 唤醒线程）的CPU时间 > 线程自旋等待的CPU时间，那么可以考虑使用自旋锁。
        > 二值信号量和计数信号量 
            > 信号量有二值信号量和计数信号量2种，其中二值信号量比较常用。
            > 二值信号量表示信号量只有2个值，即0和1。信号量为1时，表示临界区可用，信号量为0时，表示临界区不可访问。
            > 二值信号量表面看和自旋锁很相似，区别在于争用自旋锁的线程会一直循环尝试获取自旋锁，
            > 而争用信号量的线程在信号量为0时，会进入睡眠，信号量可用时再被唤醒。
            > 计数信号量有个计数值，比如计数值为5，表示同时可以有5个线程访问临界区。
    2) API
        sema_init(struct semaphore *, int)	以指定的计数值初始化动态创建的信号量
        init_MUTEX(struct semaphore *)	以计数值1初始化动态创建的信号量
        init_MUTEX_LOCKED(struct semaphore *)	以计数值0初始化动态创建的信号量（初始为加锁状态）
        down_interruptible(struct semaphore *)	以试图获得指定的信号量，如果信号量已被争用，则进入可中断睡眠状态
        down(struct semaphore *)	以试图获得指定的信号量，如果信号量已被争用，则进入不可中断睡眠状态
        down_trylock(struct semaphore *)	以试图获得指定的信号量，如果信号量已被争用，则立即返回非0值
        up(struct semaphore *)	以释放指定的信号量，如果睡眠队列不空，则唤醒其中一个任务

        //信号量结构体具体如下：
        /* Please don't access any members of this structure directly */
        struct semaphore {
            spinlock_t        lock;
            unsigned int        count;
            struct list_head    wait_list;
        };
        //可以发现信号量结构体中有个自旋锁，这个自旋锁的作用是保证信号量的down和up等操作不会被中断处理程序打断。

    3) 用法
        #include <linux/semaphore.h>

        //定义并声明一个信号量，名字为mr_sem，用于信号量计数
        static DECLARE_MUTEX(mr_sem);

        //试图获取信号量，信号未获取成功时，进入睡眠，此时线程状态为 TASK_INTERRUPTIBLE
        //也可以用down(&mr_sem), 这个方法把线程状态置为 TASK_UNINTERRUPTIBLE 后睡眠
        down_interruptible(&mr_sem);
       
        /* 临界区 ... */
       
        //释放给定的信号量
        up(&mr_sem);

        //一般用的比较多的是down_interruptible()方法，因为以 TASK_UNINTERRUPTIBLE 方式睡眠无法被信号唤醒。


(5) 读写信号量
    读写信号量和信号量之间的关系与读写自旋锁和普通自旋锁之间的关系差不多。
    读写信号量都是二值信号量，即计数值最大为1，增加读者时，计数器不变，增加写者，计数器才减一。也就是说读写信号量保护的临界区，最多只有一个写者，但可以有多个读者。
    读写信号量的相关内容参见：<asm/rwsem.h> 具体实现与硬件体系结构有关。

(6) 互斥体(mutex)
    1) 特点
        > 互斥体
            一种可以睡眠的锁，相当于二值信号量，只是提供的API更加简单，使用的场景也更严格一些。mutex的计数值只能为1，也就是最多只允许一个线程访问临界区
        > 进程上下文
            mutex不能在中断或者下半部中使用，也就是mutex只能在进程上下文中使用
            在同一个上下文中上锁和解锁，不能递归的上锁和解锁
            持有个mutex时，进程不能退出，mutex只能通过官方API来管理，不能自己写代码操作它
        > 互斥体与信号量
            只要满足互斥体的使用场景就尽量优先使用互斥体
        > 互斥体与自旋锁
            低开销加锁          优先使用自旋锁
            短期锁定	        优先使用自旋锁
            长期加锁	        优先使用互斥体
            中断上下文中加锁     使用自旋锁
            持有锁需要睡眠	    使用互斥体
    2) API
        #include <linux/mutex.h>

        mutex_lock(struct mutex *)	    //为指定的mutex上锁，如果锁不可用则睡眠
        mutex_unlock(struct mutex *)	//为指定的mutex解锁
        mutex_trylock(struct mutex *)	//试图获取指定的mutex，如果成功则返回1；否则锁被获取，返回0
        mutex_is_locked(struct mutex *)	//如果锁已被争用，则返回1；否则返回0

(7) 完成变量
    完成变量的机制类似于信号量
    比如一个线程A进入临界区之后，另一个线程B会在完成变量上等待，线程A完成了任务出了临界区之后，使用完成变量来唤醒线程B

(8) 大内核锁
    大内核锁已经不再使用，只存在与一些遗留的代码中

(9) 顺序锁(seqlock, 读写锁的一种优化)
    1) 特点
        > 读锁、写锁
            读锁被获取的情况下，写锁仍然可以被获取
            写者与写者之间仍然是互斥的，即如果有写者在进行写操作，其他写者必须自旋在那里，直到写者释放了顺序锁
        > 限制与使用场景
            必须要求被保护的共享资源不含有指针，因为写者可能使得指针失效，但读者如果正要访问该指针，将导致OOPs
            顺序锁优先保证写锁的可用，所以适用于那些读者很多，写者很少，且写优于读的场景。
        > 原理
            读之前和读之后都会检查顺序锁的序列值，如果前后值不符，则说明在读的过程中有写的操作发生，那么读操作会重新执行一次，直至读前后的序列值是一样的。
            do
            {
                /* 读之前获取 顺序锁foo 的序列值 */
                seq = read_seqbegin(&foo);
            ...
            } while(read_seqretry(&foo, seq)); /* 顺序锁foo此时的序列值!=seq 时返回true，反之返回false */
    2) API
        #include <linux/seqlock.h>

        //定义一个顺序锁有两种方式
        seqlock_t seqlock
        seqlock_init(&seqlock)      //方法一
        DEFINE_SEQLOCK(seqlock)     //方法二

        //写
        write_seqlock(&seqlock);
        /* -------- 写临界区 ---------*/
        write_sequnlock(&seqlock);

        //读
        unsigned long seq;
        do { 
            seq = read_seqbegin(&seqlock); 
        /* ---------- 这里读临界区数据 ----------*/
        } while (read_seqretry(&seqlock, seq)); 

(10) RCU(读写锁的另一种优化)


(11) 禁止抢占
    自旋锁禁止内核和中断抢占。禁止抢占提供了仅仅禁止内核抢占

(12) 顺序和屏障

(13) 
```

