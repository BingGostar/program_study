jquery发送数据，nodejs接收数据
get post
post有四种提交方式
post请求分两部分，header 和 body
1、application/x-www-form-urlencoded
最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，就会以这种方式提交
POST http://www.example.com HTTP/1.1
Content-Type: application/x-www-form-urlencoded;charset=utf-8
title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3
jquery提交实例：
text传递：
data: $("#form").serialize() a=1&b=2&c=3   
dataType = "text"

json传递：


表单转换：$("#form").serialize() a=1&b=2&c=3   
$("#form").serializeArray() [
                     {name:'a',value:'1'},
                     {name:'b',value:'2'},
                     {name:'c',value:'3'},
        						]
$('botton').click(function(){


});



nodejs接受json
ajax{	//客户端发送

}
nodejs发送json
var data={user:'malx',age:12,msg:'aaaaa'};
res.end(JSON.stringify(data));



//openssl
加密相当于我自己生成一把锁和一把钥匙，然后把锁发给你，你用我的锁把想发给我的东西锁上再发给我，我收到之后用钥匙打开锁。天下人都能拿到我的锁，但只有我有这把锁的钥匙。这个例子中，钥匙相当于私钥，锁相当于公钥。数字加密涉及三个过程：
    - 生成一对公钥和私钥
    - 加密：公钥+明文->密文
    - 解密：私钥+密文->明文


签名相当于我自己生成一把锁和一把钥匙，然后把我想发布的内容用我的锁锁起来形成一个签名，把内容和签名一起发布，并且告诉大家我的钥匙是什么。人们可以拿到钥匙来打开签名里的内容来验证是不是跟发布的内容一致。天下人都能拿到钥匙来验证签名与内容的一致性，但只有我有签名的锁。这个例子中，钥匙相当于公钥，锁相当于私钥。数字签名涉及三个过程：
    - 生成一对公钥和私钥
    - 签名：私钥+内容->签名
    - 验证：公钥+签名+内容->内容有没有改变

 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。

https改变了通信方式，它由以前的http—–>tcp，改为http——>SSL—–>tcp；https采用了共享密钥加密+公开密钥加密的方式
https连接过程
客户端发送请求到服务器端
服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在
证书由权威机构颁发（公钥+申请者与颁发者的相关信息+签名），并且对公开密钥做了签名（见上面签名），客户端
客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端

服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端
客户端使用共享密钥解密数据
SSL加密建立………



---
#### 分层协议
```
(1)应用层
HTTP（Hypertext Transfer Protocol 超文本传输协议，显示网页）
DNS（Domain Name System）
FTP（File Transfer Protocol）
SFTP（SSH File Transfer Protocol，和FTP不一样）
SCP（Secure copy，based on SSH）
SSH （Secure Shell）

(2)通信层
TCP（Transmission Control Protocol 三次握手传输协议）
UDP

(3)网络层
IP（Internet Protocol）
ICMP（Internet Control Message Protocol，主要用于路由发送错误报告）

(4)链接层：
MAC（media access control）
```

---
#### FTP
```
FTP是在TCP/IP网络和INTERNET上最早使用的协议之一，它属于网络协议组的应用层。
FTP客户机可以给服务器发出命令来下载文件，上载文件，创建或改变服务器上的目录。
相比于HTTP，FTP协议要复杂得多。复杂的原因，是因为FTP协议要用到两个TCP连接，一个是命令链路，
用来在FTP客户端与服务器之间传递命令；另一个是数据链路，用来上传或下载数据。FTP是基于TCP协议的
```

---
#### SFTP
```
SFTP与 FTP有着几乎一样的语法和功能。SFTP为SSH的一部份，是一种传输文件到服务器的安全方式。
```

---
#### scp
```
进行远程文件复制的，并且整个复制过程是加密的。数据传输使用ssh，并且和使用和ssh相同的认证方式，提供相同的安全保证
```

---
#### ftp sftp scp比较
```
FTP 基于TCP来传输文件，明文传输用户信息和数据。
SFTP 基于SSH来加密传输文件，可靠性高，可断点续传。
SCP 是基于SSH来加密拷贝文件，但要知道详细目录，不可断点续传。
```

---
#### http与https的port
端口号 https默认端口 443， http默认的端口号是80

---
#### 跨域访问

---
#### rpc vs websocket

---
#### favicon.ico
浏览器的两次http请求

---
#### 长连接与短链接
TCP协议的长连接和短连接
```
(1)长连接
数据传输完成了保持TCP连接不断开(不发RST包、不四次握手),等待在同域名下继续用这个通道传输数据；相反的就是短连接。
Connection: keep-alive
keep-alive: timeout=20  //表示TCP通道可以保持20s

```

---
#### FIN与RST

---
#### TCP报文

---
#### Cookie、session和localStorage、以及sessionStorage
```
cookie localStorage sessionStorage属于浏览器存储
localStorage生命周期是永久
sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了
注意：服务器无法直接获取localStorage、以及sessionStorage
```

---
#### cookie与签名cookie
```
```

---
#### 浏览器缓存
ETag、Cache-Control

---
#### X-Forwarded-For
X-Forwarded-For: client1, proxy1, proxy2, proxy3

---
#### X-Powered-By
隐藏响应的server

---
#### X-Requested-With 
```
如果 requestedWith 为 null，则为同步请求。
如果 requestedWith 为 XMLHttpRequest 则为 Ajax 请求。
```

---
#### SMTP POP3 IMAP
```
简单地说，SMTP管‘发’，POP3/IMAP管‘收’。
POP是负责邮件程序和邮件服务器收信的通讯协定，SMTP则是负责邮件服务器与邮件服务器之间的寄信的通讯协定
SMTP: 发送方的邮件服务器发送报文到接收方邮件服务器.
POP3: 简单的邮件访问协议,单向的,本地对邮件的操作不会同步到邮件服务器,用来从邮件服务器取得邮件.
IMAP: 比POP3更复杂的邮件访问协议，是双向的，对保存到本地的邮件的操作会同步到邮件服务器。
```

---
#### go 与 epoll
当一个goroutine读取/写入网络socket时候阻塞，系统会自动使用epoll/kqueue/iocp 来处理，这个对用户是全透明的。

```
epoll -> go server
https://blog.csdn.net/yxw2014/article/details/79375384
```

---
#### 三次握手
```
服务器端在调用listen之后，内核会建立两个队列，SYN队列和ACCEPT队列，其中ACCPET队列的长度由backlog指定。
服务器端在调用accpet之后，将阻塞，等待ACCPT队列有元素。
客户端在调用connect之后，将开始发起SYN请求，请求与服务器建立连接，此时称为第一次握手。
服务器端在接受到SYN请求之后，把请求方放入SYN队列中，并给客户端回复一个确认帧ACK，此帧还会携带一个请求与客户端建立连接的请求标志，也就是SYN，这称为第二次握手
客户端收到SYN+ACK帧后，connect返回，并发送确认建立连接帧ACK给服务器端。这称为第三次握手
服务器端收到ACK帧后，会把请求方从SYN队列中移出，放至ACCEPT队列中，而accept函数也等到了自己的资源，从阻塞中唤醒，从ACCEPT队列中取出请求方，重新建立一个新的sockfd，并返回。
```

---
### 服务器的核心功能 
功能模块:
配置文件解析
数据库

中间件：
parser  
compress  
cookie
session
安全（CORS、防止多次递交表单、session劫持防范、CSRF、XSS、SQL注入、加密解密，反爬机制，防止暴力破解账号密码）
static
logger

增加的功能:
websocket
RPC

---
### 浏览器存储持久化 
```
sessionStorage.setItem("annotation_url","<%=annotation_url%>");
```

---
### http代理head知识
```
//代理路径
X-Forwarded-For: client, proxy1, proxy2
只能作为参考

//代理认证（客户端与代理服务器之间的认证,）
Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
用户名和密码通过:拼接后进行base64编码而成(QWxhZGRpbjpvcGVuIHNlc2FtZQ==)

//remoteAddress
//例如：client->IP1->IP2->IP3->service
//服务器收到的头
RemoteAddress: IP3
X-Forwarded-For: client,IP0, IP1, IP2
注意RemoteAddress无法伪造，x-Forwarded-For可以伪造

//浏览器启用正向代理后，会对 HTTP 请求报文做一些修改
//浏览器代理前->代理后的改变
GET / HTTP/1.1
Host: www.example.com
Connection: keep-alive
 
GET http://www.example.com/ HTTP/1.1
Host: www.example.com
Proxy-Connection: keep-alive
注意：
    有了代理就麻烦了，代理不知道GET / HTTP /1.0  这个请求发给哪个主机，所以HTTP 1.0 又要求浏览器给代理发送的时候必须发送完整的路径名称
    GET http://www.example.com/ HTTP/1.0
    HTTP 1.1 规定了必须包含Host主机名这个字段。所以 HTTP 1.1 可以是
    GET / HTTP/1.1
    Host: www.example.com
    但是由于不清楚代理是1.0 还是1.1的 也许代理不认识Host这个头。 所以http 1.1 发给代理的最后格式就变为
    GET http://www.example.com/ HTTP/1.1
    Host: www.example.com

//代码    
var http = require('http');
var net = require('net');
var url = require('url');
function request(cReq, cRes) {
    var u = url.parse(cReq.url);
    var options = {
        hostname : u.hostname, 
        port     : u.port || 80,
        path     : u.path,       
        method     : cReq.method,
        headers     : cReq.headers
    };
    var pReq = http.request(options, function(pRes) {
        cRes.writeHead(pRes.statusCode, pRes.headers);
        pRes.pipe(cRes);
    }).on('error', function(e) {
        cRes.end();
    });
    cReq.pipe(pReq);
}
http.createServer().on('request', request).listen(8888, '0.0.0.0');
```

---
### https代理（隧道代理）
```
//普通的http代理是不能用作https代理的，没有证书无法与服务器建立TLS链接
//假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。
//代码
var http = require('http');
var net = require('net');
var url = require('url');
function connect(cReq, cSock) {
    var u = url.parse('http://' + cReq.url);
    var pSock = net.connect(u.port, u.hostname, function() {
        cSock.write('HTTP/1.1 200 Connection Established\r\n\r\n');
        pSock.pipe(cSock);
    }).on('error', function(e) {
        cSock.end();
    });

    cSock.pipe(pSock);
}
http.createServer().on('connect', connect).listen(8888, '0.0.0.0');

```


---
### 短连接与长连接
```
短连接：短连接是指服务端与客户端每次完成通讯后，就断开连接套接字Socket ConnectSocket的连接，同时每次需要服务端与客户端产生通讯的时候，都要重新创建连接套接字Socket ConnectSocket，最典型的短连接应该就是HTTP了吧（当然从HTTP/1.1起，HTTP默认使用长连接）
长连接：用于对于客户端来说，其只需要一个连接套接字Socket ConnectSocket就能完成与服务端所有的通讯，因此对于长连接来说，客户端只需在最开始创建一个连接套接字Socket ConnectSocket，便可以和服务端反复通讯多次。而当一个连接套接字Socket ConnectSocket长时间存在，其便会出现两个问题：1、当Socket ConnectSocket的连接如果被中断后，我们再去使用这个Socket ConnectSocket进行通讯时，其便会出错；2、如果服务端不断地接收客户端的连接并创建相应的连接套接字Socket ConnectSocket，却又不去关闭已经失效的Socket ConnectSocket，那么服务端迟早将会挂掉。由于会出现以上这两个问题，为此便引申出了KeepAlive机制。
KeepAlive机制：简单地来讲就是让一台主机每隔一段时间不停地向另一台远程主机发送连接请求（心跳包），以确认对方是否仍处于连接状态，如果发现对方长时间不应答，便关闭与对方连接。理论上来说服务端和客户端都可以向对方发送心跳包，但一般来说都是由客户端向服务端发送心跳包。在TCP中，KeepAlive机制默认是如果对方2小时不应答，则会断开连接，但是由于2小时时间过长，因此一般我们都要重写该机制。
```

---
### 代理协议(加密)
```
//代理协议
HTTPS，SOCKS5-TLS 和 shadowsocks

//代理级数
(1) 透明代理
在透明代理中，代理服务器将客户端的信息转发至目标访问对象，并没有完全隐藏客户端真实的身份。即服务器知道客户端使用了代理IP，并且知道客户端的真实IP地址。
(2) 普通匿名代理
在普通匿名代理中，代理服务器用自己的IP代替了客户端的真实IP，但是告诉了目标访问对象这是代理访问。
(3) 欺骗匿名代理
在欺骗匿名代理中，目标访问对象同样可以察觉客户端使用代理访问，但是代理服务器会用一个随机的IP代替客户端真实的IP。
(4) 高匿代理
在高匿代理中，代理服务器良好地伪装了客户端，不但用一个随机的IP代替了客户端的IP，也隐藏了代理信息，服务器不会察觉到客户端是通过代理实现访问的，即用户仿佛就是直接使用代理服务器作为自己的客户端。
通常，服务器通过获取HTTPRequest的头部信息的相关字段来判断客户端是否使用了代理。该字段包括REMOTE_ADDR、HTTP_VIA、HTTP_X_FORWARDED_FOR等。

//识别ip代理
对于透明代理和普通匿名代理，代理服务器一般会在HTTP头上加入一些信息，可以通过判断HTTP头来校验是否是通过代理访问。对于高匿代理，代理服务器会直接转发请求，不会有任何附加信息，这种情况下，只能通过IP反查来判断是否是代理服务器（你得到当前访问的IP后，反向发送请求回这个IP对各端口进行扫描来判断是否是代理；当然，也有很多第三方的商用反网络欺诈服务提供商，你可以在他们的数据库中查询当前访问的IP是否是一个他们已知的代理服务器）

//tcp代理（socks5和shadowsocks都属于tcp代理）
（1）socks
    浏览器<--->代理服务器<--->饿了么网站
（2）shadowsocks
    浏览器<--->SSlocal<--->SSServer<--->网站
    SSlocal 会将浏览器发来的数据加密，发送给 SSServer ， SSServer 把数据解密后发给网站。

//抗识别
单纯的socks5代理很容易被识别，一般不用。
用shadowsocks吧

```

---
### 内网穿透和隧道
```
这个和上面的代理不一样，代理是客户端用代理服务器进行上网，而内网穿透是通过公网ip服务器与内网ip服务器建立一个隧道，外部访问公网ip，相当于访问内网ip
```

---
### MSS
```
TCP的最大报文段大小
1460Bytes(1500BytesMTU - 20Bytes(IP Header) - 20Bytes(TCP Header))
```

---
### Seq和Win
```

```

---
### 滑动窗口
```
```

--- 
### MTU和ip total length
```

```

--- SYN ACK Seq
```
```

---
### tcp滑动窗口
```

```
---
### 再认跨域
```
之前全理解错了！！！
应该是防止别的url访问本服务器，所以应该在本服务器设置access头

在aaa.com页面中需要跨域访问bbb.com，bbb.com只允许自己的域访问，所以aaa.com连接不通bbb.com.
只有在bbb.com服务端设置access头才能实现aaa.com对bbb.com的访问

``` 

### User-Agent
```

```

---
### CDN
```
//CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络"边缘"，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度
//CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现

用户-->浏览器域名解析库--->cdn域名---->ip地址
     `-> CNAME解析 ----|
         A记录解析
```

---
### 堡垒机
```
当前公司控制内部人员登陆服务器加上的中间层，但是web可以直接访问服务器
例如：直接ssh 10.100.6.13失败必须通过堡垒机（https://10.10.99.146/fort/frame.action）才能访问
但是在10.100.6.13上面开启8000端口，就可以直接网页访问此端口

//按功能分
网关型堡垒机: 堡垒机不提供路由功能,将内外网从网络层隔离开来，处理应用层的数据内容,性能消耗很大
运维审计型堡垒机: 截获运维人员的操作，
//类别分
硬件堡垒机：外形就像个DVD影碟机
软件堡垒机：对现有网络结构存在一定程度的入侵，会改变运维习惯。
云堡垒机：???


外部 -> | -> Nginx -> 交换机 -> 服务器集群

客户端 -> ssh(:22) ❌ -> 服务器集群
    `-----> 堡垒机 ---->  服务器集群
    `--> http :8000 -->  服务器集群

```