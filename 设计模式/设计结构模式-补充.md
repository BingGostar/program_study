### 结构型模式
```
1、适配器模式
    (1) 定义
        将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)
    (2) 结构
        Target
            目标抽象类
        Adapter
            适配器类
        Adaptee
            适配者类
        Client
            客户类
    (3) 代码实现
        // 目标抽象类
        class Target {
            virtual void request() = 0;
        };

        // 适配器类
        class Adapter : public Target{
            Adapter(Adaptee* adaptee_) {
                adaptee = adaptee_;
            }

            virtual ~Adapter(){}

            virtual void request() {
                adaptee->specificRequest();
            }
        private:
            Adaptee* adaptee;
        }

        // 适配者类
        class Adaptee {
            void specificRequest();
        }

        // 使用
        Adaptee *adaptee = new Adaptee();
        Target *tar = new Target(adaptee);
        tar->request();

2、桥接模式
    (1) 定义
        将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式

    (2) 结构
        Abstraction
            抽象类
        RefinedAbstraction
            扩充抽象类
        Implementor
            实现类接口
        ConcreteImplementor
            具体实现类
        // 例如
          (Abstraction)          (Implementor)
               形状 ---------------> 颜色
                |        包含         |  
           +----+----+          +-----+-----+
           |         |          |           |
          圆形      方形        黄色        绿色
        (RefinedAbstraction)  (ConcreteImplementor)

    (3) 代码展示
        https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180712208-505786819.png

3、装饰模式！！！
    (1) 定义
        装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同
        动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合
    (2) 结构
        Component
            抽象构件
        ConcreteComponent
            具体构件
        Decorator
            抽象装饰类
        ConcreteDecorator
            具体装饰类
    (3) 代码表述
        // 例如：给手机贴膜、装手机壳、装挂件

        // 抽象构建
        class Component {
        public:
            virtual void operation() = 0;
        };

        // 具体构建
        class Phone : public Component {
        public:
            void operation() {
                cout << "手机" << endl;
            }
        };

        // 抽象装饰类
        class Decorator : public Component {
        public:
            Decorator(Component* comp):component(comp){}
            void operation() {
                component->operation();
            }
        private:
            Component* component;
        };

        // 具体装饰类
        // 贴膜
        class DecoratorSticker : public Decorator {
        public:
            DecoratorSticker(Component* comp):Decorator(comp){}
            void operation() {
                Decorator::operation();
                cout << "贴膜" << endl;
            }
        };
        // 装壳
        class DecoratorShell : public Decorator {
        public:
            DecoratorShell(Component* comp):Decorator(comp){}
            void operation() {
                Decorator::operation();
                cout << "装壳" << endl;
            }
        };
        // 挂绳
        class DecoratorRope : public Decorator {
        public:
            DecoratorRope(Component* comp):Decorator(comp){}
            void operation() {
                Decorator::operation();
                cout << "挂绳" << endl;
            }
        };

        // 用法
        Component *c = new Phone();
        Component *c1 = new DecoratorSticker(c);
        Component *c2 = new DecoratorSticker(c1);
        Component *c3 = new DecoratorSticker(c2);
        c3->operation();
```

