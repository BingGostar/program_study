### 资料
```
https://blog.csdn.net/enlyhua/article/details/81024206
```

### 高性能服务器程序框架
```
服务器程序通常要处理三类事情：IO事件，信号，以及定时事件

(1) 服务器模型
	1) C/S 模型
	2) P2P 模型
 
(2) 服务器编程框架
	1) IO处理单元 : 
		> 处理用户连接，读写网络数据；(单机)
		> 作为接入服务器，实现负载均衡;(集群)
	2) 请求队列
		> 各个单元之间通信的抽象，通常被实现为池的一部分；
		> 一个单元通知另外一个单元，或者多个单元访问同一个存储单元时，竞争的协调；
		> 对于集群来说，请求队列是预先建立的
	3) 逻辑单元
		> 一个进程或者线程；(单机)
		> 一台逻辑服务器；(集群)
	4) 网络存储单元
		> 数据库，文件，缓存;(单机)
		> 数据库服务器;(集群)
 
(3) I/O 模型
	1) 阻塞IO
	2) 非阻塞IO
	3) IO复用(IO通知机制)
		> select, poll, epoll_wait
		> 应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数把其中准备就绪的事件通知给应用程序
		> IO复用本身是阻塞的，高效的原因是它同时监听多个IO事件的能力
	4) SIGIO 
		可以用来报告IO事件, 将一个目标文件描述符指定为宿主进程，被指定的进程将捕获到SIGIO事件，这样就可以在信号处理函数中对目标文件描述符执行非阻塞IO操作了
	5) 异步IO
		libaio
	6) 注意	
		理论上说，阻塞IO,IO复用，信号驱动IO 都是同步IO模型。因为这3种IO模型，IO的读写，都在 IO事件发生以后，由应用程序自己完成
		对异步IO而言，用户可以直接对IO执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及IO完成后内核通知应用程序的方式，总是立即返回，真正的读写已经由内核接管。
		同步IO模型要求用户自行执行IO操作，异步IO则由内核来执行IO操作；
		同步IO向应用程序通知的是IO就绪事件，异步IO向应用程序通知的是IO完成事件；
 
(4) 两种高效的事件处理模式
	1) Reactor(同步IO模型) :
		要求主线程只负责监听文件描述符上是否有事件发生，有的话通知工作线程读写数据，接受新的连接，以及处理客户请求均在工作线程中完成
		> 主线程往epoll内核事件注册socket上的读就绪事件
		> 主线程调用epoll_wait等待socket上有数据可读
		> 当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读线程事件放入请求队列
		> 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
		> 主线程调用epoll_wait等待socket可写
		> 当socket可写时，epoll_wait通知主线程.主线程将socket可写事件放入请求队列
		> 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户端请求的结果

	2) Proactor(异步IO模型)
		与Reactor模式不同，Proactor模式将所有的IO操作都叫给主线程和内核来处理，工作线程仅仅负责业务逻辑
		> 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序
		> 主线程继续处理其他逻辑
		> 当socket上的数据被读入用户缓冲区后，内核向应用程序发送一个信号，以通知应用程序数据已经可用
		> 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户的请求
		> 工作线程处理完客户请求后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成
		时如何通知应用程序
		> 主线程继续处理其他逻辑
		> 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。
		> 应用程序预先设定好的信号处理函数选择一个工作线程来善后处理，比如决定是否关闭socket 
 
	3) 同步IO模拟Proactor
		原理：主线程执行数据读写操作，读写完成后，主线程向工作线程通知这一"完成事件"。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的就是对读写的结果进行逻辑操作。
		> 主线程往epoll内核事件表中注册socket上的读就绪事件
		> 主线程调用epoll_wait等待socket上有数据可读
		> 当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读
		> 然后将读到的数据封装成一个请求对象并插入请求队列
		> 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件
		> 主线程调用epoll_wait等待socket可写
		> 当socket可写时，epoll_wait通知主线程，主线程往socket上写入服务器处理客户请求的结果

(5) 两种高效的并发模式
	
	并发编程模式
	1) 半同步/半异步
		> IO编程的"同步"和"异步"
			在IO编程中，区分的是内核向应用程序通知的是何种IO事件(是就绪事件还是完成事件)，以及谁来完成IO读写(是应用程序还是内核)
		> 并发编程的"同步"和"异步"
			在并发模式中，"同步"指的是程序完全按照代码序列的顺序执行，"异步"指的是程序的执行需要由系统事件来驱动，常见的系统事件包括中断，信号等
			同步运行的线程叫同步线程，异步方式运行的线程叫异步线程
		> 半同步/半异步模式(类似Proactor)
			同时采用同步线程和异步线程来实现
			这当中，同步用来实现客户逻辑，异步线程用来处理IO事件。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象
			图例：
			（从fd读取数据、处理，然后写入fd，响应客户端）
			工作线程 <---+
			工作线程 <---|		
			工作线程 <---|
						|	+-----------------------------------+
						+---| buf | buf | buf | buf | buf | buf |
							+-----------------------------------+
									↑   ↑   ↑    ↑    ↑   ↑
									+----------+----------+
											   |	
											异步IO...
											   ↑	
											accept
											   ↑
											socket
									   ↑      ↑      ↑      ↑	
									client client client client

 		> 半同步/半反应堆模式(类似Reactor)
		 	半同步/半异步模式的变种
			异步线程只有一个，由主线程来充当。它负责监听所有socket的事件
			> 如果监听socket上有可读事件发生，即有新的连接到来，主线程就接受之以得到新的连接socket,然后往epoll内核事件表中注册该socket 上的读写事件
			> 如果连接socket上有读写事件发生，即有新的客户请求到来或者有数据要发送至客户端，主线程就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列中，当有任务到来，它们通过竞争获取任务的接管权。
			> 缺点：
				> 主线程和工作线程共享请求队列
					主线程往请求队列添加任务，或者工作线程从请求队列取出任务，都需要对请求队列加锁保护，从而浪费cpu时间
				> 每个工作线程在同一时间之内处理一个客户请求
					客户数量较多，工作线程较少，则请求队列中将堆积很多任务对象
					如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量cpu时间。

		> 高效的半同步/半反应堆模式：
			在工作线程中也维护自己的事件循环。
 
	2) 领导者/追随者
		领导者和追随者是多个工作线程轮流获得事件源集合，轮流监听，分发并处理事件的一种模式
		> 一个领导者，多个追随者
			在任意时间点，程序仅有一个领导者，它负责监听IO事件
			其他线程都是它的追随者，它们休眠在线程池中等待成为新的领导者
			当期领导者如果检测到IO事件，首先要从线程池中推选出现的领导者线程，然后处理IO事件。此时，新的领导线程等待新的IO事件，而原来的领导者则处理IO事件，二者实现了并发。
 		> 领导者/追随者模式包括的组件(句柄集，线程集，事件处理器和具体的事件处理器)
			> 句柄集
				表示IO资源，使用wait_for_event方法监听这些句柄上的IO事件。
				将其中的就绪事件，通知给领导线程。领导者则调用绑定到Handle上的事件处理器来处理事件
				领导者将Handle和事件处理器绑定是通过调用句柄集中的register_handle 实现的。
 			> 线程集
		  		这个组件是所有工作线程(包括领导线程和追随者线程)的管理者，它负责各个线程之间的同步，以及新领导线程的推选
				线程集中的线程在任一时间必须处于如下三种状态之一：
		  		> Leader
					线程当前处于领导者身份，负责等待句柄集上的IO事件；		
		  		> Processing
					线程正在处理事件
					领导者检测到IO事件后，可以转移到 Processing 状态来处理该事件，并调用promote_new_leader方法推选新的领导者；也可以指定其他追随者来处理事件，此时领导者地位不变。当处于Processing状态的线程处理完事件之后，如果当前线程集中没有领导者，则它将成为新的领导者，否则它就直接转变为追随者。
		  		> Follower
					线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可以被当前的领导者指定来处理新任务。
			> 事件处理器和具体的事件处理器：
				事件处理器通常包含一个或多个回调函数handle_event，这些回调函数用于处理事件对应的业务逻辑
				事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数
				具体的事件处理器是事件处理器的派生类，它们必须重新实现基类的handle_event方法，以处理特定任务

(6) 有限状态机
	逻辑单元内部的一种高效编程方式
 
(7) 提高服务器性能的其他建议
	1) 池
		一组资源的集合。这组资在服务器启动之初就完全被创建并初始化。因为分配系统资源的系统调用很耗时，可以避免了对内核的频繁访问
		内存池：socket的接收缓存和发送缓存
		进程池
		线程池
		连接池：常用于服务器或服务器集群的内部永久连接
 
	2) 数据复制
		高性能服务器应该避免不必要的数据复制，尤其是当数据复制发送在用户代码和内核之间的时候
		> 如果内核可以直接处理从socket或者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复制到应用程序缓冲区(这里说的"直接处理"指的是应用程序不关心这些数据的内容，不需要对它们做任何分析)
		> 可以使用"零拷贝"sendfile函数
		> 此外，用户代码内部(不访问内核)的数据复制也应该避免。
			例如，当2个工作进程之间要传递大量的数据时，我们就应该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递。
 
	3) 上下文切换
		并发程序必须考虑上下文切换的问题，即进程切换或线程切换导致的系统开销。
		即使是IO密集型的服务器，也不应该使用过多的工作线程。否则线程间的切换将占用大量的cpu时间，服务器真正用于处理业务逻辑的cpu时间的比重就显得不足了
		因此，每个客户连接创建一个工作线程的服务器模型是不可取的
 		半同步/半异步模式是一种比较合理的方案，它允许一个线程同时处理多个客户连接
		此外，多线程服务器的一个优点是不同的线程可以同时运行在不同的cpu上，当线程的数量不大于cpu的数目时，上下文切换就不是问题了。
 
	4) 锁
		并发程序需要考虑的另外一个问题就是对共享资源的加锁保护
		锁通常被认为是导致服务器效率低下的一个因素。因为由它引入的代码，不仅不处理任何业务逻辑，而且需要访问内核资源。
		显然，半同步/半异步模式(Proactor)就比半同步/半反应堆的效率高(Reactor)
		如果服务器必须使用锁，可以考虑减小锁的粒度
```
