# 指令集体系结构(ISA)
## 定义
```
> 指令集体系结构
> 逻辑设计和硬件控制语言HCL
> 顺序实现
> 流水线原理
> 流水线实现

(1) 概念
一个处理器支持的指令和指令的字节级编码就是这个处理器的ISA

ISA 在编译器编写者和处理器设计人之间提供了一个抽象概念层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出这些指令的处理器。

可见部分包括：寄存器、存储器、条件码、PC（程序计数器）、程序状态。

(2) 作用
ISA在编译器编写者（CPU软件）和处理器设计人员（CPU硬件）之间提供了一个抽象层
```

#### cpu分支预测、流水线和条件转移
(1)流水线
指令从取值到真正执行的过程划分成多个小步骤(取指、译码、执行、访存、写回)，cpu真正开始执行指令序列时，一步压一步的执行，减少其等待时间。
```
每一步是一个时钟周期，如果级数越多，每个周期执行的就越多，性能就越好（注意！不是越多越好）
1->2->3
   1->2->3
      1->2->3
每个时钟周期都完成一条指令的性能      
```

(2)分支预测
如果猜对了，火车可以直接开往要去的方向
如果猜错了，火车要停下来，然后倒车，然后将车轨扳到正确的方向，然后火车重新开往正确的方向。
如果预测对了，那就不用停下来了
[分支预测](https://www.cnblogs.com/yangecnu/p/4196026.html)

(3)likely和unlikely
```
#define likely(x)  __builtin_expect(!!(x), 1)
#define unlikely(x)    __builtin_expect(!!(x), 0)
//上述源码中采用了内建函数__builtin_expect来进行定义,__builtin_expect函数用来引导gcc进行条件分支预测
```

### 原码、反码、补码
```
(1) 原码
    原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值
    比如如果是8位二进制:
    [+1]原 = 0000 0001
    [-1]原 = 1000 0001

(2) 反码
    1) 为什么需要反码
        原码最大的问题就在于一个数加上他的相反数不等于零
        例如：0001+1001=1010 (1+(-1)=-2) 0010+1010=1100 (2+(-2)=-4)
        反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那我们干脆用一个正数按位取反来表示负数试试
    2) 什么是反码
        正数的反码还是等于原码
        负数的反码就是他的原码除符号位外，按位取反
        [+1] = [00000001]原 = [00000001]反
        [-1] = [10000001]原 = [11111110]反

        0001+1110=1111 （1+（-1）= - 0）
        互为相反数相加等于0，解决。虽然是得到的结果是1111也就是-0

(3) 补码
    1) 为什么需要补码
        1 - 1 = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

    2) 什么是补码
        正数的补码就是其本身
        负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)
        [+1] = [00000001]原 = [00000001]反 = [00000001]补
        [-1] = [10000001]原 = [11111110]反 = [11111111]补
        
        1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

        (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补=[1111 1111]原
```

### 图像系统架构
```
https://blog.csdn.net/huoyahuoya/article/details/54708295
https://www.cnblogs.com/liqiu/p/3499582.html
https://blog.csdn.net/u013895853/article/details/81586915
https://blog.csdn.net/youyou1543724847/article/details/84192430 ❗


(1) Windowing system（窗口系统）
    > client-server架构
        server（称作display server，或者windows server、compositor等等）管理所有输入设备，以及用于输出的显示设备
    > x client
        应用程序作为display server的一个client，在自己窗口（window）中运行，并绘制自己的GUI
    > x server
        client的绘图请求，都会提交给display server，display server响应并处理这些请求，以一定的规则混合、叠加，最终在有限的输出资源上
    > x protocol
        display server和自己的client之间，通过某种类型的通信协议交互，该通信协议通常称作display server protocol
    
    X client <--> X protocol <--> X server <--> linux kernel

(2) X Window System
    Windowing System一种实现，X Window 系统广泛的应用于桌面 Linux
    架构
              keyborad mouse screen
                 ↑       ↑     ↑
        +------------------------------+
        |  +------------------------+  |
        |  |        x server        |  |
        |  +------------------------+  |  
        |     ↑          ↑        ↑    | 
        |     ↓          ↓        |    |
        | x client   x client     |    |
        | (browser)  (browser)    |    |
        +-------------------------|----+
                                  |
                                 net  
                                  |
                                remote
    注意：
        X只提供实现GUI环境的基本框架，如定义protocol、在显示设备上绘制基本的图形单元（点、线、面等等）、和鼠标键盘等输入设备交互、等等。它并没有实现UI设计所需的button、menu、window title-bar styles等元素，而是由第三方的应用程序提供。


(3) 窗口管理器、GUI工具集、桌面环境及其它
    1) 窗口管理器(application windows)
        负责控制应用程序窗口的布局和外观，使每个应用程序窗口尽量以统一、一致的方式呈现给用户，如针对X的最简单的窗口管理程序–twm（Tab Window Manager）
    2) GUI工具集
        GUI工具集是Windowing system之上的进一步的封装。
        xlib提供给应用程序的API，仅仅可以绘制基本的图形单元（点、线、面等等），这些基本的图形单元
        在xlib基础上封装出一些更为便利的GUI接口，方便应用程序使用，如Microwindows、GTK+、QT等等
    3) 桌面环境
        桌面环境是应用程序级别的封装，通过提供一系列界面一致、操作方式一致的应用程序，使系统以更为友好的方式向用户提供服务。Linux系统比较主流的桌面环境包括GNOME、KDE等

    xlib -> GTK/QT -> GNOME/KDE

(4) 3D渲染、硬件加速、openGL等
    OpenGL只是一个API，它与Applications和Toolkits，应用软件同级
    对上，屏蔽硬件细节，为应用程序提供相对稳定的、平台无关的3D图像处理API
    对下，指引硬件相关的驱动软件，实现3D图像处理相关的功能
```
![系统架构](https://upload.wikimedia.org/wikipedia/commons/c/c2/Linux_Graphics_Stack_2013.svg)

### SaaS PaaS LaaS
```
https://www.zhihu.com/question/20387284

// LaaS(Infrastructure as a service – 基础设施即服务)
    用户可以在云服务提供商提供的基础设施上部署和运行任何软件，包括操作系统和应用软件
    常见的IaaS服务有虚拟机、虚拟网络、以及存储（阿里云、Amazon EC2）

// PaaS(Platform as a service – 平台即服务)
    PaaS给用户提供的能力是使用由云服务提供商支持的编程语言、库、服务以及开发工具来创建、开发应用程序并部署在相关的基础设施上
    常见的PaaS服务有数据库服务、web应用以及容器服务

// SaaS(Software as a Service – 软件即服务)
    给用户提供的能力是使用在云基础架构上运行的云服务提供商的应用程序
    类似的服务有：各类的网盘(Dropbox、百度网盘等)，JIRA，GitLab，qq
```

### js
```
(1)PhantomJS浏览器内核，可以在linux运行浏览器，爬虫的终极解决方案
```

### 安全
```
rootkit
```

### 激活 win10
```
slmgr.vbs /upk
slmgr /ipk 2F77B-TNFGY-69QQF-B8YKP-D69TJ
slmgr /skms kms.03k.org
slmgr /ato
```

### openstack，docker，mesos，k8s 关系
```
OpenStack
    针对 Iaas 平台，以资源为中心，可以为上层的 PaaS 平台提供存储、网络、计算等资源

Docker
    主要针对 Paas 平台，是以应用为中心

Kubernetes(k8s)
    面向应用的 PaaS 层，强项在于容器编排，可以很好解决应用上云的问题

Mesos
    Apache的顶级开源项目，管理的核心目标对象既不是虚拟机/物理机，也不是容器，而是各种各样的计算资源（CPU、memory、disk、port、GPU等等）

```

### k8s + docker
```
k8s用于容器和虚拟机集群的管理，一切都基于分布式

一个K8S系统，通常称为一个K8S集群（Cluster）
这个集群主要包括两个部分：一个Master节点（主节点）和一群Node节点（计算节点）


1、Master组件
    Master组件提供集群的管理控制中心，它可以在集群中任何节点上运行
    (1) kube-apiserver
        用于暴露Kubernetes API。任何的资源请求/调用操作都是通过kube-apiserver提供的接口进行
    (2) ETCD
        etcd是Kubernetes提供默认的一致性系统，可用于存储集群的相关数据
    (3) kube-controller-manager
        管理控制器，它们是集群中处理常规任务的后台线程。逻辑上，每个控制器是一个单独的进程
        1) 节点（Node）控制器
        2) 副本（Replication）控制器
            负责维护系统中每个副本中的pod
        3) 端点（Endpoints）控制器
            填充Endpoints对象（即连接Services＆Pods）
        4) Service Account和Token控制器
            为新的Namespace 创建默认帐户访问API Token
    (4) cloud-controller-manager
        1) 节点（Node）控制器
        2) 路由（Route）控制器
        3) Service控制器
        4) 卷（Volume）控制器
    (5) kube-scheduler
        监视新创建没有分配到Node的Pod，为Pod选择一个Node

2、Node组件
    提供Kubernetes运行时环境，以及维护Pod。一个Node可以是VM或物理机
    (1) kubelet
        kubelet是主要的节点代理，它会监视已分配给节点的pod
        安装Pod所需的volume、下载Pod、Pod中运行的 docker（或experimentally，rkt）容器、定期执行容器健康检查等
    (2) kube-proxy
        维护网络规则并执行连接转发来实现Kubernetes服务抽象，每一个节点也运行一个简单的网络代理和负载均衡
    (3) docker
        docker用于运行容器
    (4) RKT
        rkt运行容器，作为docker工具的替代方案
    (5) supervisord
        supervisord是一个轻量级的监控系统，用于保障kubelet和docker运行
    (6) fluentd
        fluentd是一个守护进程，可提供cluster-level logging


```