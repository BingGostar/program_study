
### 一致性
```
分布式系统的事务处理与数据一致性

1、ACID
    事务是由一系列对数据进行访问与更新的操作所组成的一个程序执行逻辑单元，特指数据库事务
    当多个程序并发访问数据时，事务可以提供一个隔离方法，防止相互干扰
    事务具有四个特性：Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性）
    > Atomicity
        事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。
        事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
    > Consistency
        事务开始前和结束后，数据库的完整性约束没有被破坏
        比如A向B转账，不可能A扣了钱，B却没收到。
    > Isolation
        同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰
        比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账
        隔离级别    脏读    可重复度    幻读
        未授权读取  存在    不可以      存在
        授权读取    不存在  不可以      存在
        可重复读取  不存在  可以        存在
        串行化      不存在  可以        不存在
    > Durability
        事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚
    
2、分布式事务
    在分布式领域，为了确保业务的完整与正确性，分布式事务无法避免，而且非常复杂
    
3、CAP
    在分布式系统中很难做到ACID，所以提出了CAP
    CAP理论主张基于网络的数据共享系统，都最多只能拥有以下三条中的两条
    Consistency（一致性）、Available（可用性）、Partition Tolerance (分区容错性)
    > 一致性
        指数据多个副本之间是否能够保持一致
        即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致
    > 可用性
        指系统提供的服务必须一直处于可用的状态，强调每一个操作总是能够在"有限时间内" "返回结果"
        好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况
    > 分区容错性
        即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务
        分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响
        
    CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：
    > CA without P (违背分布式)
        如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的
    > CP without A
        如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库
    > AP wihtout C
        要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞
    
4、BASE
    基于CAP理论发展而来，核心思想是即便不能达到强一致性，但可以根据应用特点采用适当的方式达到最终一致性
    BasicallyAvailable（基本可用）、Soft State（软状态）、Eventual consistent（最终一致性）
    > Basically Available
        假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言
        响应时间上的损失、功能上的损失
    > Soft state
        硬状态是多个节点的数据副本都是一致的
        软状态允许系统在多个不同节点的数据副本存在数据延时
    > Eventually consistent
        保证数据最终一致性

```

### 一致性协议
```
https://zhuanlan.zhihu.com/p/31780743
https://www.cnblogs.com/linbingdong/p/6253479.html

为了需要在系统可用性与数据一致性之间进行反复权衡，于是产生了一致性协议

1、2PC(二阶段提交)
    包含协调者和参与者
    协调者负责调度参与者的行为，并最终决定这些参与者是否把事务真正进行提交
    绝大多数关系型数据库采用二阶段提交协议来完成分布式事务处理
    (1) 协议
        1) 阶段一(提交事务请求)
            协调者组织参与者对事物投票表态阶段
            1> 事务询问
                协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待参与者响应
            2> 执行事务
                各参与者执行事务操作，并记录undo和redo信息
            3> 反馈响应
                事务执行成功的参与者反馈给协调者yes响应，表示事务可以执行。相反不能成功执行的参与者返给协调者no响应，表示事务不可以执行
        2) 阶段二(执行事务提交)
            参与者投票表明是否要继续执行事务提交操作，分为两种情况
            1> 执行事务提交
                假如协调者从所有参与者获得的反馈都是yes，则会执行事务提交
                协调者向所有参与者节点发出commit请求
                1> 事务提交
                    参与者收到commit请求后，会正式执行事务提交操作，然后释放事务执行期间占用的资源
                2> 反馈提交结果
                    参与者完成事务提交后，向协调者发送ACk消息
                3> 完成事务
                    协调者收到所有参与者的ACK后，完成事务
                
            2> 中断事务
                协调者向所有参与者节点发出commit请求后，假如任何一个参与者反馈no响应或等待超时后，则会中断事务
                1> 发送回滚请求
                    协调者向所有节点发出Rollback请求
                2> 事务回滚
                    参与者收到Rollback后，会利用undo执行事务回滚，完成回滚后释放资源
                3> 反馈事务回滚结果
                    参与者完成回滚后，向协调者发送ACK消息
                4> 中断事务
                    协调者收到所有参与者的ACK消息后，完成事务中断

    (2) 优缺点
        虽然上述协议原理简单，实现方便，但是存在以下缺点
        1) 同步阻塞
            二阶段提交过程中，所有参与该事务的操作都处于阻塞状态。各个参与者会存在等待其他参与者的情况，严重影响性能
        2) 单点问题
            一旦协调者出现问题，整个系统无法运行
        3) 数据不一致
            二阶段提交过程中，因为一些故障导致一部分参与者收到commit请求，而另一部分没有收到commit请求，会出现数据不一致的情况
        4) 太过保守
            没有容错机制，任意一个节点失败会导致整个事务失败

2、3PC
    (1) 协议
        1) CanCommit
            1> 事务询问
                协调者向所有参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并等待响应
            2> 参与者反馈响应
                参与者收到canCommit请求后，如果认为自己执行事务提交操作，则返回yes响应，并进入预备状态，否则反馈no
        2) PreCommit
            协调者会根据参与者的反馈情况来决定事务的操作，存在两种可能
            1> 执行事务预提交
                假如所有的参与者都返回yes响应，则执行事务预提交
                1> 发出预提交请求
                    协调者向所有参与者发出preCommit请求，并进入prepare阶段
                2> 事务预提交
                    参与者收到preCommit请求后执行事务操作，并记录undo和redo
                3> 反馈事务执行响应
                    如果参与者成功执行了事务，就会反馈协调者ACK响应，同时等待最终指令(提交或终止)
            2> 中断事务
                假如任何一个参与者返回no响应或等待超时，则就会中断事务
                1> 发送中断请求
                    协调者向所有参与者发送abort请求
                2> 中断事务
                    参与者收到abort请求或者等待请求超时，都会出现中断事务
        3) doCommit
            该阶段进行真正的事务提交，存在两种可能
            1> 执行提交
                1> 发送提交请求
                    假如协调者处于正常状态，并受到所有参与者的ACK响应，那么将状态从预提交转换为提交，并向所有参与者发送doCommit请求
                2> 事务提交
                    参与者收到doCommit请求后，会正式执行事务提交操作，然后释放事务执行期间占用的资源
                3> 反馈提交结果
                    参与者完成事务提交后，向协调者发送ACk消息
                4> 完成事务
                    协调者收到所有参与者的ACK后，完成事务
            2> 中断事务
                这一阶段，假如协调者处于正常状态，并且任意一个参与者返回no响应或者等待超时，就会进入中断事务
                1> 发送中断请求
                    协调者向所有参与者发出abort请求
                2> 事务回滚
                    参与者收到abort后，会利用阶段二记录的undo执行回滚操作，然后释放事务执行期间占用的资源
                3> 反馈事务回滚结果
                    参与者完成回滚后，向协调者发送ACK消息
                4> 中断事务
                    协调者收到所有参与者的ACK消息后，完成事务中断

            注意：一旦进入三阶段，会出现两种状况
            1> 协调者出现问题
            2> 协调者和参与者之间网络出现故障
            上述情况会出现参与者无法收到来自协调者的doCommit或abort请求
            对于这样情况，参与者都会在等待超时后，继续进行事务提交
    (2) 优缺点
        1) 优点
            与二阶段相比最大优点是降低参与者的阻塞范围，并且在出现单点故障后继续达成一致
        2) 缺点
            参与者接收到preCommit后，如果网络出现分区，协调者和参与者无法进行正常通信，这是参与者依然会进行事务提交，必然导致数据不一致

3、Paxos
    Paxos算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。
    Paxos算法解决的问题正是分布式一致性问题，即一个分布式系统中的各个进程如何就某个值（决议）达成一致
    (1) 三个角色
        Proposer: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。
        Acceptor：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。
        Learner：不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）。
    (2) Proposer与Acceptor
        1) Proposer生成提案
            1> Prepare请求
                Proposer生成一个新的提案编号N，然后向某个Acceptor集合的成员发送'编号为N的Prepare请求'，要求集合中的成员做出以下回应(承诺诺)
                > 不再批准任何编号小于N的提案
                > 如果Acceptor已经接受过提案，那么就向Proposer反馈当前已批准编号小于N的最大编号的提案
            2> Accept请求
                > 确定提案
                    如果Proposer收到了半数以上的Acceptor的响应，那么它就可以生成编号为N，value值为V的提案。这里的V是所有的响应中编号最大的提案的Value，N为当前Accept提案编号。如果半数以上的响应中都没有任何提案，那么此时V就可以由Proposer自己生成
                > 发送提案               
                    在此Proposer确定提案后，然后再将此提案(N, V)发给某Acceptor集合
        2) Acceptor批准提案
            Acceptor处理逻辑：一个Acceptor只接受编号大于已响应过编号的请求
            Acceptor会收到来自Proposer的两种请求Prepare和Accept
            1> 响应Prepare(N)请求，做出是否响应此编号
                如果编号N小于等于之前Acceptor承诺的编号，那么拒绝此响应。否则接受响应，并返回已批准的最大编号的提案(如果有)
            2> 响应Accept(N, V)请求，做出是否批准此提案
                如果编号N小于之前Acceptor承诺的编号，那么拒绝此提案。否则接受此提案，并且承诺不接受编号小于等于的N的响应
        
    (3) 算法两个阶段描述
        两个阶段可能轮回交替
        1) 阶段一
            1> Prepare
                Proposer生成全局唯一且递增的编号N，然后向所有Acceptor发送编号为N的Prepare请求(这里无需携带内容)
            2> Promise
                Acceptor收到编号为N的Prepare请求，做出"两个承诺，一个应答"
                两个承诺
                1> 不再接受任何编号小于等于N的Prepare请求
                2> 不再接受任何编号小于N的Propose提案
                一个应答
                如果一个Acceptor收到一个编号为N的Prepare请求，且N大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将它批准过的编号最大的提案(注意此处是批准的提案，不是承诺的提案编号，说明已经历了Accept过程)作为响应反馈给Proposer，如果没有批准过提案，则返回空值
                
        2) 阶段二
            1> Propose
                如果Proposer收到半数以上的Acceptor对于其发出编号N的Prepare请求做出了响应，然后从收到的提案中选择编号最大的提案valueMax，将自身的编号(注意不是最大编号)和此值，即(N, valueMax)发送给所有的Acceptor。如果响应中不包含任何提案，那么就填上任意值
            2> Accept
                Acceptor收到Propose(N, valueMax)请求后，只要该Acceptor尚未对编号大于N的Prepare请求做出响应，那么接受此提案(持久化，发送给learner)。否则拒绝此提案

        伪代码描述:

                      Proposer(N, V)                              Acceptor(ResN, AcceptN, AcceptV)

                   |  Prepare(N)全局唯一，递增 -+                 
                   |                           |               
                   |                           +----------------> def Prepare(N):
            step1  |                                                 if N <= ResN:
                   |                                                    不响应或return(err)
                   |                                                 if N > ResN:
                   |                                                    ResN = N
                   |                                    +--------       return (ok, AcceptN, AcceptV) 或 (ok, null, null)
                                                        |
                   |  if 收到超半数的ok响应 <------------+
                   |       V
                   |       if 响应有提案:
                   |          V = 响应中获得最大提案编号对应的值
                   |       else:
                   |          V = 自己定义
                   |       发起Accept(N, V)请求
                   |  else:
                   |       重新获取N
            step2  |       重新发起Prepare(N)请求
                   |               |
                   |               +--------------------------->  def Accept(N, V):
                   |                                                 if N >= ResN:
                   |                                                     AcceptN = N
                   |                                                     AcceptV = V
                   |                                                     ResN = N
                   |                                                     return (ok)
                   |                                                 else:
                   |               +---------------------------          return (err)
                   |               ↓
                   |  收到超半数响应ok，说明已接受提案
                   |  否则，没有接受提案，重新Prepare


    (4) 活锁
        假设有两个Proposer一次提出编号递增的提案，最终会陷入死循环(无法保证活性)
        > Proposer P1发出编号为M1的Prepare请求，收到过半ok响应。完成阶段一流程
        
        > Proposer P2发出编号为M2(M2>M1)的Prepare请求，也收到过半ok响应。也完成阶段一流程，此时Acceptor承诺不再接受编号小于M2的提案

        > P1进入第二阶段，发出Accept(M1)请求，Acceptor拒绝请求(M1<M2)，P1重新发出编号M3(M3>M2)的Prepare请求，Acceptor收到请求后承诺不再接受编号小于M3的提案

        > P2进入的二阶段，发出Accept(M2)请求，Acceptor拒绝请求(M2<M3)，P2又重新Prepare请求

        > 进入死循环

        解决方案：选取一个主Proposer，只有主Proposer才能提出议案(Prepare)


    (5) Learner方案
        Learner学习（获取）被选定的value有如下三种方案
        1) Acceptor接受一个提案，然后发送给所有Learner
            优点：Learner能尽快的获取被选定的提案
            缺点：通信次数高(m*n)

        2) Acceptor接受一个提案，然后发送给主Learner，主Learner再通知其他Learner
            优点：通信次数少(m+n-1)
            缺点：主Learner出现故障

        3) Acceptor接受一个提案，然后发送给部分Learner，部分Learner再通知其他Learner
            优点：可靠性好
            缺点：太复杂
```

### Chubby
```
paxos协议的实现

1、系统结构
    (1) Master
        一个Chubby集群(通常5台服务器)，采用Paxos选择一台master，master租期期间不会有其他服务器成为master，master会不断续租，直到master出现故障，新一轮选举，产生新master
    (2) 数据存储方式
        集群中每个服务器都维护一份数据库副本，但只有master才有写数据库的权限，其他服务器使用Paxos协议从master服务器上同步数据
    (3) 定位Master
        请求DNS服务器获得所有Chubby服务器列表，轮询该列表。如果是非Master服务器则会返回Master地址
    (4) 请求的发送
        客户端会将所有请求发给Master。对于写请求，Master会采用Paxos将其广播给集群中的所有服务器，在收到过半响应后，在返回给客户端；对于读请求，Master不会进行广播处理，则直接返回给客户
    (5) 服务器故障处理
        master故障会重新选举
        非master故障，整个集群不会停止，此崩溃服务器会在恢复后自动加入Chubby集群中去
        新加入的服务器，需要先同步Chubby最新数据库，更新DNS列表，然后加入到正常的Paxos运作流程中
    (6) 服务器地址变更
        在Chubby运行过程中，Master会周期的轮询DNS列表。当感知到服务器地址列表变更时，Master会将集群数据库中的地址列表作相应的变更，然后其他服务器通过复制的方式获得最新的服务器地址列表     

2、几个关键的问题
    (1) 锁
        > 分布式锁错乱
            一个客户C1获取到互斥锁L1，然后发出请求R，但是没有到达服务器。另一个用户C2获取到互斥锁L2，也发出请求，并成功应用到服务器上。不幸的是，C1客户的请求经过一波三折到达了服务器，有可能会更改之前C2的数据
        > 锁序列器
            锁序列器可以解决此问题，任何时候请求的锁会带有锁的名字、锁模式(读、写)、锁序号。当带有锁的请求到达服务器时，服务器会先检查锁序号是否有效，以及检查是否处于恰当的锁模式来决定是否拒绝此请求
    (2) 客户端如何获得服务端状态
        客户端获得Chubby服务端状态不是通过轮询来获得的，而是通过注册事件通知，常见事件如下：
        文件内容变更
        节点新增删除
        Master转移
    (3) 缓存
        > 为什么需要
            为了避免客户端频繁的请求服务端，客户端会存在缓存来存储相关信息（文件内容和元数据信息）。但是会带来系统复杂性，最主要就是缓存一致性
        > 缓存一致性
            > 原理
                通过租期机制来保存缓存一致性
                Master通过向每个客户端发送过期信息来保证客户端数据一致性，会导致客户端要么从缓存中得到一致性数据，要么访问出错
            > 解决方法
                > 客户端缓存会存在一个租期，一旦到期需要向服务器续订租期来维护一致性
                > 当要修改数据时，Chubby服务端会阻塞该修改操作，然后Master向'所有'缓存该数据的客户端发送缓存过期信号使其失效。等到Master收到所有客户端的应答时(客户端允许缓存过期或要求更新缓存)，再继续进行之前的修改操作
                总之Chubby是通过强一致性来解决此问题的。尽管性能开销比较大，但是很稳
    (4) KeepAlive
        Chubby客户端与服务端的通信都是基于TCP来进行操作的

    待续。。。
        
```

### Zookeeper
```
Zookeeper是一个典型的分布式数据一致性解决方案
分布式应用程序可以基于它实现 数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁、分布式队列等功能

特点
    顺序一致性
    原子性
    单一视图
    可靠性
    实时性

设计目标
    简单的数据模型
        服务器内存中的一个数据模型，有一系列的称为ZNode数据节点组成
        Znode之间的层级关系就像文件系统的目录结构一样
    构建集群
        Zookeeper集群(3~5台服务器)的每台机器都会在内存中维护当前的服务器状态，并且之间维持通信
        只要超一半机器正常那么此集群正常
        Zookeeper客户端与集群的任意一台机器相连，一旦断开后，会自动连接到其他机器
    顺序访问
        来自客户端的请求，Zookeeper都会分配全局唯一的递增编号
        此编号反映了所有事务操作的先后顺序，应用程序可以使用这个特性实现同步原语
    高性能
        全景数据存储在内存中

基本概念
    集群角色
        分为Leader, Follower, Observer三种角色，非主从模式
        > 通过选举产生一台Leader
        > Leader提供'读写'服务
        > Follower和Observer提供'读'服务
        > Observer机器不参与Leader选举，也不参与'过半写成功策略'

    session
        一个客户端连接指客户端与服务器之间的一个长连接
        第一次建立连接开始，客户端会话生命周期也开始

    数据节点
        > 数据模型
            数据模型的单元称为数据节点(ZNode)
            数据模型是一棵树(ZNode Tree)，由'/'分割路径，就是一个ZNode，例如/foo/path1
            每个ZNode上保存自己的内容和一系列属性信息
        > 分类
            > 持久节点
                ZNode一旦创建会一直保存在Zookeeper上，除非主动删除
            > 临时节点
                生命周期和客户端会话绑定
    版本
        对应于每个ZNode，Zookeeper会维护一个Stat数据结构
        Stat记录了这个ZNode的三个数据版本
        version     当前Znode的版本
        cversion    当前Znode子节点的版本
        aversion    当前Znode的ACL版本
    
    Watcher
        事件监听器，Zookeeper的一个重要特性
        Zookeeper允许用户在'指定节点'上注册一些Watcher，并且在一些特定事务触发时，Zookeeper服务端会将事件通知到'之前指定'的节点上

    ACL
        Zookeeper采用ACL策略来进行权限控制，类似UNIX文件系统的权限控制，定义以下权限
        CREATE  创建子节点权限
        READ    获取节点数据和子节点列表权限
        WRITE   更新节点数据权限
        DELETE  删除子节点权限
        ADMIN   设置节点ACL权限

```

### ZAB 协议
```
1、原理
    > 所有事务由一个全局唯一的Leader服务器处理，剩下的是Follower服务器
    > Follower服务器负责将客户请求转换成一个Proposal提议，然后分发给所有Followers
    > Leader等待所有Follow反馈
    > 当Leader收到超过半数的Proposal'正确'反馈，那么Leader向所有的Follower分发commit消息
    > Follower收到commit消息，将前一个Proposal提交

                Propose             Propose
             <---------          ---------->  
                Ack                 Ack
    Follower ---------->  Leader <---------- Follower
                Commit      ↑       Commit            
             <----------    |    ---------->
                            |
                          request

2、协议
    (1) 两种模式
        ZAB协议有两种模式，分别是'崩溃恢复'和'消息广播'
        > '消息广播'模式到'崩溃恢复'模式
            当leader服务器出现网络中断、崩溃退出和重启等异常情况，ZAB协议会进入恢复模式，并选举出新的Leader
        > '崩溃恢复'模式到'消息广播'模式
            当选举出新的Leader时，同时集群中过半的机器与该leader完成状态同步后，ZAB协议会退出崩溃恢复模式

    (2) 消息广播模式

数据同步
ZXID是64位数字
高32位代表Leader周期的epoch编号
低32代表事务递增计数器


主进程周期
    一个主进程
        ZAB协议在任何时候需要保证只有一个主进程负责消息广播

    多个主进程
        如果主进程崩溃时，会选出一个新的主进程
        随着时间推移，会出现多个主进程构成的序列：P1,P2...Pe，e表示主进程号

    如何保持一致
        为了保证主进程每次广播的事务消息都是一致的。必须确保完成崩溃恢复后，新的主进程才可以开始生成新的事务消息广播
        
    实现
        各个进程都实现类似ready(e)函数调用，可以明确的告知上层系统(主进程和副进程)是否可以进行事务消息的广播


```

