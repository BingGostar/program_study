### Google File System
```
它构建在廉价的普通PC服务器之上，支持自动容错
GFS内部将大文件划分为大小约为64MB的数据块（chunk），并通过主控服务器（Master）实现元数据管理、副本管理、自动负载均衡等操作

GFS是Google分布式存储的基石，google其他存储系统直接或间接构建在GFS之上

1、系统架构
    > 三种角色
        GFS Master（主控服务器）、GFS ChunkServer（CS，数据块服务器）以及GFS客户端

    > 数据块chunk
        GFS文件被划分为固定大小的数据块，由主服务器在创建时分配一个64位全局唯一的chunk句柄
        ChunkServer将chunk以linux文件的形式存放在磁盘中
        为了确保可靠性，chunk在不同的机器上复制三分

    > 主控服务器
        维护了系统的元数据(包括文件及chunk命名空间、文件到chunk之间的映射、chunk位置信息)
        负责整个系统的全局控制(chunk租约管理、垃圾回收无用chunk、chunk复制等)

    > 客户端
        提供给应用程序的访问接口
        客户端访问GFS时，首先访问主控服务器节点，获取与之进行交互的CS信息，然后直接访问这些CS，完成数据存取工作
        客户端不缓存文件数据，只缓存主控服务器中获取的元数据
        注意
            > MapEeduce客户端使用方式为顺序读写，没有缓存文件数据的必要
            > Bigtable作为分布式表格系统，内部实现了一套缓存机制
            > 如何维护客户端缓存与实际数据之间的一致性是一个极其复杂的问题

2、关键问题
    (1) 租约机制
        > 租约的授权
            为了减轻Master的压力，GFS系统通过租约lease机制将chunk'写操作的权利'授权给ChunkServer
        > 主ChunkServer、备ChunkServer
            拥有租约的ChunkServe称为主ChunkServer，其他副本所在的ChunkServer称为为备ChunkServer
        > 租约有效期
            租约的有效期比较长(比如60秒)，只要没有出现异常，主ChunkServer可以不断向Master请求延长租约的效期直到整个chunk写满，然后再向Master申请
        > 版本号机制
            GFS对每个chunk维护一个版本号，每次给chunk进行租约授权或者主ChunkServer重新延长租约有效期时，Master会将chunk的版本号加1
        > 垃圾回收
            对于更新失败的chunk，版本号过低导致被Master标记为可删除
            Master的垃圾回收任务会定时检查，并通知ChunkServer将标记的chunk删除
        注意
            > 写权限不是主server向备server写数据(发送数据流)，而是主向备server发送可写操作，数据流可能是其他server发送的
            > Master在租约上面有两个功能
                > 授权给ChunkServer的写权限
                > 给新的chunk的版本号加一，之后的数据io操作由主chunkserver管理
    (2) 追加流程
        GFS主要是为了追加(append)而不是改写(overwrite)而设计的
        一方面是因为改写的需求比较少，主要是因为顺序写增加性能
        高效支持记录追加对基于GFS实现的分布式表格系统Bigtable是至关重要的，也是最复杂的

        

        步骤
        1) client请求Master
            client向Master请求chunk每个副本所在的位置，其中主ChunkServer持有修改租约
            如果没有ChunkServer持有租约(没有主ChunkServer)，说明该chunk最近没有写操作，Master会发起一个任务，按照一定的策略将chunk的租约授权给其中一台ChunkServer
        2) Master返回chunk的位置信息
            master返回chunk的主chunkserver和备chunkserver信息，client将缓存这些信息
        3) 发送副本
            1> 方法
                > 流水线发送
                    流水线操作用来减少延时
                    当一个ChunkServer(无论主还是备)接收到一些数据，它就立即开始转发
                    由于采用全双工网络，立即发送数据并不会降低接收数据的速率
                > 分离数据流与控制流的方法
                    主要是为了优化数据传输，每一台机器都是把数据发送给网络拓扑图上'最近'的尚未收到数据的数据
                > 基于主备复制方法
                    先把数据发给主ChunkServer，然后主ChunkServer再发给备CHunkServer
            2> 两种流程
                1> GFS流程
                    采用'分离数据流与控制流的方法'和'流水线'，充分利用网络拓扑，实现复杂
                    从近到远发送副本
                    > 客户端将要追加的记录发送到每一个副本，每一个ChunkServer会在内部的LRU结构中缓存这些数据
                    > 当所有副本都确认收到了数据，客户端发起一个写请求控制命令给主副本
                    > 由于主副本可能收到多个客户端对同一个chunk的并发追加操作，主副本将确定这些操作的顺序并写入本地
                    > 主副本把写请求提交给所有的备副本(每一个备副本会根据主副本确定的顺序执行写操作)
                    > 备副本成功完成后应答主副本
                    > 主副本应答客户端，如果有副本发生错误，将出现主副本写成功但是某些备副本不成功的情况，客户端将重试

                    +<--> 客户端 <---> 主控服务器
                    |       ↓  
                    |     备副本A <-->+
                    |       ↓        |
                    +<--> 主副本 <--->+
                            ↓        | 
                          备副本B <-->+

                2> MapReduce流程
                    采用'主备复制方法'和'流水线'，实现简单
                    先发送给主副本，然后主副本再通过流水线的方式发送给备副本
                    > Client将待追加数据发送到主副本(chunkserver)，主副本可能收到多个客户端的并发追加请求，需要确定操作顺序，并写入本地
                    > 主副本将数据通过流水线的方式转发给所有的备副本
                    > 每个备副本收到待追加的记录数据后写入本地，所有副本都在本地写成功并且收到后一个副本的应答消息时向前一个副本回应

                    客户端 <--> 主控服务器
                      ↑↓  
                    主副本
                      ↑↓
                    备副本A
                      ↑↓
                    备副本B
        
        需要考虑的问题
        1) 追加的过程中可能出现主副本租约过期而失去chunk修改操作的授权
        2) 主副本或者备副本所在的ChunkServer出现故障

    (3) 容错机制

```         
