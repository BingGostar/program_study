### 套接字地址
```
// 字节序
    小端/大端         大端
    处理器字节序 ---> 网络字节序

    #include <arpa/inet.h>
    uint32_t htonl(uint32_t hostint32)  返回 网络字节序32位整数
    uint16_t htons(uint16_t hostint16)  返回 网络字节序16位整数
    uint32_t ntonl(uint32_t netint32)   返回 主机字节序32位整数
    uint16_t ntons(uint16_t netint16)   返回 主机字节序16位整数

1、通用socket地址
    不同的地址格式必须转换为此格式
    #include <sys/socket.h>
    struct sockaddr {
        sa_family_t  sa_family;     //地址族 unsigned short, AF_xxx
        char         sa_data[14];   //14字节 包含套接字中的目标地址和端口信息     
    }
    // 大小16个字节
2、专用socket地址
    (1) IPv4
        #include<netinet/in.h>
        typedef uint16_t in_port_t;
        typedef uint32_t in_addr_t;
        struct sockaddr_in {    
            sa_family_t     sin_family;     // 地址族 AF_INET
            in_port_t       sin_port;       // 16位端口号
            struct in_addr  sin_addr;       // 32位IP地址
            unsigned char   sin_zero[8];    // Same size as struct sockaddr，补齐剩余的字符
        }
        struct in_addr {
            in_addr_t       s_addr           // 32位IPv4地址；A.B.C.D 
        }

    (2) IPv6
        struct sockaddr_in6 { 
            sa_family_t     sin6_family;    // AF_INET6
            in_port_t       sin6_port;      // 16位端口号
            uint32_t        sin6_flowinfo;  // IPv6 flow information
            struct in6_addr sin6_addr;      // IPv6 address
            uint32_t        sin6_scope_id;  // 
        }
        struct in6_addr { 
            unsigned char   s6_addr[16];    // 128位IPv6地址长度；XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX
        }

    (3) unix域套接字地址
        #include <sys/un.h>
        struct sockaddr_un {
			sa_family_t     sun_family;     // AF_UNIX
            char            sun_path[108];  // pathname
        }

3、addr转换
    (1) tcp套接字转换
		struct sockaddr_in my_addr;
		my_addr.sin_family      = AF_INET;
		my_addr.sin_port        = htons(80);                 //uint16转换成网络字节序
		my_addr.sin_addr.s_addr = inet_addr("192.168.2.201") //inet_addr将字符串转换为网络字节序，inet_ntoa则将网络字节序转换为字符串
		bzero(&(my_addr.sin_zero), 8);                       //sin_zero置0
		struct sockaddr* myaddr = (struct sockaddr*)&my_addr //转换成sockaddr

	(2) unix域套接字转换
		struct sockaddr_un un;
		memset(&un, 0, sizeof(un));
		un.sun_family = AF_UNIX;
		strcpy(un.sun_path, "foo.socket");
		struct sockaddr *myaddr = (struct sockaddr*)&un;
	
	// socket绑定addr
	if((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		err_sys("socket failed");
	if(bind(fd, myaddr, sizeof(myaddr)) < 0)
		ERR_EXIT("bind");
```

### 套接字相关函数
```
1、socket函数
    #include <sys/socket.h>
    int socket(int domain, int type, int protocol)
    // domain(域)
		AF_INET     IPv4
		AF_INET6    IPv6
		AF_UNIX     UNIX域

    // type
		SOCK_DGRAM  UDP(固定长度、无连接、不可靠报文传递)
		SOCK_RAM    ip协议数据报接口，用于直接访问网络层，绕过传输层(tcp、udp)，需要超级用户特权
		SOCK_STREAM TCP(有序、可靠、双向、面向连接字节流)

    // protocol    	0           表示为给定的域和套接字选择默认协议

2、bind函数
    // 将地址绑定在套接字上
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	// 返回值	为0时表示绑定成功，-1表示绑定失败，errno查看错误值
	// errno值
		EADDRINUSE	给定地址已经使用	
		EBADF	sockfd不合法	
		EINVAL	sockfd已经绑定到其他地址	
		ENOTSOCK	sockfd是一个文件描述符，不是socket描述符	
		EACCES	地址被保护，用户的权限不足
	// 注意
		bind可以不指定ip和port，系统会为其指定
		如果内核为套接字选择一个临时的端口号，函数并不会返回其端口号，可以调用getsockname查看端口号

3、connect
    #include <sys/socket.h>
    ing connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
	// sockfd	客户端套接字描述符
	// servaddr	包含服务器IP地址和端口号的套接字地址结构
	// addrlen	套接字地址结构的大小
	// 返回值	为0时表示绑定成功，-1表示绑定失败，errno查看错误值
	// errno值
		ETIMEDOUT	未收到响应则返回该错误(内核会先发送一个SYN，无响应则等待6s后再发送一个，若仍无响应则等待24s后再发送一个。共等待了75s)
		ECONNREFUSED	服务器对客户响应一个RST(1、主动取消；2、不存在连接)
		EHOSTUNREACH/ENETUNREACH	某个路由发送ICMP错误(地址不可达)
	// 注意
		调用connect前不必非得调用bind，如果没有bind，内核会确定源IP并选择一个临时端口作为源端口
		connect将激发TCP三路握手过程，函数会阻塞进程，直到成功或出错才返回
		connect失败则该套接字不可再用，必须关闭，不能对这样的套接字再次调用connect函数。必须close后重新调用socket
	
4、listen
	int listen(int sockfd, int backlog);
	// backlog	规定了内核应为相应套接字排队的最大连接个数，监听套接字维护两个队列(未完成连接队列、已完成连接队列)，两个队列之和不超过backlog
	// 返回值	成功返回0，失败返回-1
	// 注意
		此函数指示内核应接受指向该套接字的连接请求
		SYN到达时，如果队列已满，TCP忽略该SYN分节，不能返回RST，因为客户无法区分'连接错误'和'队列已满'
		
5、accept
    https://www.cnblogs.com/wangcq/p/3520400.html

    TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了
    TCP客户端依次调用socket()、connect()之后就向服务器发送了一个连接请求
    TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作

    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
    // sockfd 	服务器的socket描述字
    // addr		客户端的协议地址
    // addrlen	第三个参数为协议地址的长度
    // 注意
		三次握手发生在这一步
		内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭

6、close函数
	关闭套接字，并终止tcp连接
	#include <unistd.h>
	int close(int sockfd);
	// 返回值	成功0，错误-1
	// 注意
		close是把套接字标记为关闭，立即返回调用进程，然后TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后再开始TCP终止序列
		close会将套接字描述符的引用计数减1，如果引用计数仍大于0，则不会引起TCP的四次挥手终止序列

7、shutdown函数
	#include <sys/socket.h>
	int shutdown(int sockfd, int how);
	// sockfd	需要关闭的socket的描述符
	// how
		SHUT_RD(0)		关闭sockfd上的读功能，此选项将不允许sockfd进行读操作
		SHUT_WR(1)		关闭sockfd的写功能，此选项将不允许sockfd进行写操作
		SHUT_RDWR(2)	关闭sockfd的读写功能
	// 注意
		shutdown不管引用计数就能激发TCP的正常连接终止序列
		shutdown可以只关闭一个方向的数据传送，close终止读和写两个方向的数据传送
		
8、getsockname、getpeername
	获得套接字关联的本地地址
	int getsockname(int sockfd, struct sockaddr* localaddr, socklen_t* addrlen);
	获得套接字关联的外地地址
	int getpeername(int sockfd, struct sockaddr* peeraddr, socklen_t* addrlen);
```

### 套接字的连接
```
服务器启动后，调用socket, bind, listen, accept，并阻塞与accept调用

客户端调用socket，connect后，发起三次握手。握手完成后connect和accept均返回

// 连接管理
在连接之前需要设置socket选项，详见套接字选项章节
(1) TCP_MAXSEG
    该选项允许我们获取或设置TCP连接的最大分节大小(MSS)
(2) TCP_NODELAY
    开启该选项将禁止TCP的Nagle算法，默认情况下是启动的

```

### 套接字IO
```

```

### 套接字的终止
```
	
```

### 套接字选项
```
#include <sys/socket.h>

int setsockopt(int socket, int level, int option_name,const void *option_value, socklen_t option_len);
int getsockopt(int socket, int level, int option_name, void *option_value, socklen_t *option_len);

// socket		套接字
// level		level级别，一般设置SOL_SOCKET
// option_name	设置的选项
    不同的级别，设置不同的选项
    (1) SOL_SOCKET
        SO_BROADCAST    bool    使用广播方式传送
        SO_DEBUG        bool    记录调试信息
        SO_DONTROUTE    bool    绕过外出路由表查询，直接传送，送出的数据包不要利用路由设备来传输
        SO_KEEPALIVE    bool    周期测试连接是否存活
        SO_LINGER       struct linger*  若有数据待发送(关闭时有未发送数据)，则延迟关闭
        SO_RCVBUF       int     接收缓冲区大小
        SO_SNDBUF       int     发送缓冲区大小
        SO_RCVLOWAT     int     接收缓冲区低水位标记，接收缓冲区中数据大于其标记时，I/O复用系统调用将通知应用程序可以从对应的socket上读数据
        SO_SNDLOWAT     int     发送缓冲区低水位标记，发送缓冲区中数据低于其标记时，I/O复用系统调用将通知应用程序可以从对应的socket上写数据
        SO_RCVTIMEO     timeval 接收超时
        SO_SNDTIMEO     timeval 发送超时
        SO_REUSEADDR    bool    允许重用本地地址
        SO_REUSEPORT    bool    允许重用本地端口
        SO_OOBINLINE    bool    在常规数据流中接收带外数据，当接收到OOB数据时会马上送至标准输入设备
    (2) IPPROTO_IP
    (3) IPPROTO_TCP
        TCP_MAXSEG      bool    TCP最大分节大小(MSS)
        TCP_NODELAY     bool    禁止Nagle算法
// option_value	代表欲设置的值
// option_len	则为option_value的长度
// 返回值		成功则返回0, 错误返回-1, 错误原因存于errno


// 是否重用该socket
bool bReuseaddr = TRUE;
setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)&bReuseaddr,sizeof(BOOL));

// 如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历TIME_WAIT的过程
bool bDontLinger = FALSE;
setsockopt(s,SOL_SOCKET,SO_DONTLINGER,(const char*)&bDontLinger,sizeof(BOOL));

// 在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限
int nNetTimeout=1000;   // 1s
//发送时限
setsockopt(socket, SOL_S0CKET,SO_SNDTIMEO, (char *)&nNetTimeout,sizeof(int));
//接收时限
setsockopt(socket, SOL_S0CKET,SO_RCVTIMEO, (char *)&nNetTimeout,sizeof(int));

// 在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节(异步)。系统默认的状态发送和接收一次为8688字节(约为8.5K)，在实际的过程中发送数据和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发
// 接收缓冲区
int nRecvBuf=32*1024;   //设置为32K
setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&nRecvBuf,sizeof(int));
//发送缓冲区
int nSendBuf=32*1024;   //设置为32K
setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char*)&nSendBuf,sizeof(int));

// 如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响程序的性能
int nZero=0;
setsockopt(socket, SOL_S0CKET, SO_SNDBUF, (char *)&nZero,sizeof(nZero));


// 同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)
int nZero=0;
setsockopt(socket, SOL_S0CKET, SO_RCVBUF, (char *)&nZero, sizeof(int));


// 一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性
bool bBroadcast=TRUE;
setsockopt(s,SOL_SOCKET,SO_BROADCAST,(const char*)&bBroadcast,sizeof(BOOL));

// 如果在发送数据的过程中，而调用了close()后可以让关闭停留一段时间
struct linger {
	u_short l_onoff;
	u_short l_linger;
};
linger m_sLinger;
m_sLinger.l_onoff=1;	// 1：允许逗留，2：不允许逗留
m_sLinger.l_linger=5;	// 容许逗留的时间为5s
setsockopt(s,SOL_SOCKET,SO_LINGER,(const char*)&m_sLinger,sizeof(linger));

```

### SO_REUSEADDR和SO_REUSEPORT
```
https://zhuanlan.zhihu.com/p/35367402
(1) SO_REUSEADDR
    当服务端出现timewait状态的链接时，确保server能够重启成功

(2) SO_REUSEPORT(linux v3.9 引入)
    1) 场景
        多进程或者多线程都有一个独立的socket，并且bind相同的ip:port，提高接收连接的能力(每个进程或线程都要设置SO_REUSEPORT)
            Nginx新版本是多进程同时监听同一个ip:port(每个进程bind同一个ip:port，但是只有一个进程会得到响应)
    2) 解决的问题
        > 避免了应用层多线程或者进程监听同一ip:port的"惊群效应"
        > 内核层面实现负载均衡，保证每个进程或者线程接收均衡的连接数
        > 只有effective-user-id相同的服务器进程才能监听同一ip:port(安全性考虑)
            
(3) 示例
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr("0.0.0.0");
    addr.sin_port = htons(9980);

    void work () {
        int listenfd = socket(AF_INET, SOCK_STREAM, 0);
        if (listenfd < 0) _exit(-1);
        int ret = 0;
        bool reuse = TRUE;
        ret = setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,(const void *)&reuse , sizeof(int));
        if (ret < 0) _exit(-1);
        ret = setsockopt(listenfd, SOL_SOCKET, SO_REUSEPORT,(const void *)&reuse , sizeof(int));
        if (ret < 0) _exit(-1);        
        ret = bind(listenfd, (struct sockaddr *)&addr, sizeof(addr));
        if (ret < 0) _exit(-1);
        ret = listen(listenfd, 10);
        if (ret < 0) _exit(-1);
        struct sockaddr clientaddr;
        int len = 0;
        while(1) {
            int clientfd = accept(listenfd, (struct sockaddr*)&clientaddr, &len);
            if (clientfd < 0) _exit(-1);
            close(clientfd);
        }
    }
    
    int main(){
        int i = 0;
        for (i = 0; i< 6; i++) {
            pid_t pid = fork();
            if (pid == 0) {
                work();
            }
            if(pid < 0) {
                perror("fork");
                continue;
            }
        }
        int status,id;
        while((id=waitpid(-1, &status, 0)) > 0);
        if(errno == ECHILD) {
            printf("all child exit\n");
        }
        return 0;
    }
```

### 阻塞和非阻塞IO
```
```

### IO多路复用
```
```

### UDP
```
```

### TCP SCTP
```
```

### 高性能IO模型
```
```

IO函数
非阻塞

连接终止
多路复用
    epoll与select和poll区别
    epoll使用

套接字选项

UDP
STCP与TCP区别

守护进程

高性能服务框架