### ORM
```
对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。

ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是"对象-关系映射"（Object/Relational Mapping）

ORM 把数据库映射成对象。
数据库的表（table） --> 类（class）
记录（record，行数据）--> 对象（object）
字段（field）--> 对象的属性（attribute）

//Hibernate(java的ORM)
Hibernate 将 Java 类映射到数据库表中，从 Java 数据类型中映射到 SQL 数据类型中，并把开发人员从 95% 的公共数据持续性编程工作中解放出来。
```

### 数据库session
```
事务四大特征(ACID)
(1) 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。
(2) 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。
(3) 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。
(4) 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

事务的操作
    开启事务：Start Transaction
    事务结束：End Transaction
    提交事务：Commit Transaction
    回滚事务：Rollback Transaction

mysql示例
    BEGIN;      //开始一个事务
    xxxx
    如果出错：
        ROLLBACK    //事务回滚
    xxxx
    COMMIT      //事务确认

```

### 数据库缓存
```
//一级缓存
SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。
session级别的，默认开启，不可卸除，一般都会用到 

//二级缓存
全局缓存,mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。
sessionfactory（创建session，hibernate的初始化）级别的，适合1、很少别修改的数据， 

缓存首先一进来去查二级缓存，二级缓存没有去找一级缓存，一级缓存没有去找数据库。二级缓存----->一级缓存-------->数据库。
```

### 视图
```
一个比较复杂的查询不想每次都写很多语句，就可以写个视图。
或者给特定用户开放某些表的读取权限，但要加一些行和列的限制，也可以写个视图。
使用视图，可以定制用户数据，聚焦特定的数据。

安全，快速
```

### CAP
```
分布式的思想来概括的话，就是CAP。
在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），最多只能同时三个特性中的两个，三者不可兼得。

> Consistency (一致性)：
    “all nodes see the same data at the same time”,即更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。
> Availability (可用性):
    可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。
>Partition Tolerance (分区容错性):
    即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。

//CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：
> CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。

> CP without A：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。

> AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。


```

### 底层引擎数据结构
```
(1) HASH索引
    Bitcask

(2) LSM
    LevelDB、Hbase、MongoDB
    TSM
    influxdb

(3) B-tree
    Mysql Innodb、

// LSM用于顺序写，提供更快的写入性能，Btree由于更加平衡，读取性能会更强。

// hash索引更适合简单的kv存储，适合做缓存。LSM适合高并发的数据写入，B-tree更适合大量查询的应用场景，
```

### LSM
```
https://www.cnblogs.com/eaglegeek/p/4557803.html
https://www.zhihu.com/question/19887265
https://zhuanlan.zhihu.com/p/65483906
https://www.cnblogs.com/gaoguangjun/p/8513054.html
https://cloud.tencent.com/developer/news/340271

```
