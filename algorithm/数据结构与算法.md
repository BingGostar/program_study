# 动态规划

# 

# 树的遍历算法
前序遍历、中序遍历、后序遍历、层序遍历

# 人机对抗算法
```
机器博弈的核心技术是博弈搜索算法
https://blog.csdn.net/spenghui/article/details/51728739
https://www.cnblogs.com/pangxiaodong/archive/2011/05/26/2058864.html

极大极小值搜索算法
负值最大算法
Alpha-Beta搜索方法
一定要实现
```

### FSM(有限状态机)
```
https://cloud.tencent.com/developer/article/1329471

(1) 关键字
    状态：State             //注意初始状态
    事件：Event             //状态转换事件（相同的状态可能同时匹配多个事件）
    转换：Transition        //为了处理一个Event，定义的转换过程

(2) 图解
                MachineSet    
                    ↓
                    Machine       判断属于哪个event？          
    --- Event --->  Machine ---Event----------+
                    Machine                   ↓ 
                       ↑            Event1           Event2   
    并发控制 -----------+   state1 --------> state2 --------> state3
                            ↑                                    ↓    状态转换
                            +------------------------------------+
                                            Event3

(3) 状态机过程
    1) MachineSet可以同时管理多个Machine;
    2) 外部触发的Event进入到MachineSet的事件队列;
    3) 事件队列里的Event被顺序处理, 被Dispatch到match的Machine;
    4) Machine根据当前的所处的state和Event类型来判断当前Event是否有效;
    5) 如果上面(4)中的Event有效, 则进行状态转换;
    6) 状态转换具体来说涉及到三个回调函数:
        > 当前state离开, 是第一个回调,需要使用者根据实际需要处理;
        > transition这个转换过程, 是第二个回调;
        > 新state的进入, 是第三个回调;

(4) 状态机细节
    状态机的定义：通过定义State，Event，Action，Transition来实现状态机的流转，摒弃标准状态机中那些较复杂的概念（通过其他方式来实现所谓的较复杂的操作）
    状态持久化：数据持久化到数据库，实现状态机的中断重启
    上下文保存与传递：提供一套流程流转过程中参数的传递机制
    并发控制：提供不同状态机隔离，同一状态机单实例运行机制
    功能增强：接口或注解的形式实现自触发，重试，定时执行


(4) 接口
    enum class State {
        STATE1;
        STATE2;
        STATE3;
    }
    class Machine {
        void SetStartState();
        
    }

    class Event {

    }

    class Transition {
        virtual void Trans();   //转换函数
        virtual void OnEnter(); //回调
        virtual void OnExit();  //回调
        virtual void OnTrans(); //回调
    }
```