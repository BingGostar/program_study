# 概述
## 封装
[数据进入协议栈时的封装过程](../picture/10.png)
## 客户端-服务器模型
服务分为两种类型：重复型或并发型。
一般来说， T C P服务器是并发的，而U D P服务器是重复的，但也存在一些例外
## 端口号
大多数Unix系统的文件/etc/services都包含了人们熟知的端口号
## 应用编程接口
TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI

# 链路层
## 链路层目的
```
（1）为IP模块发送和接收IP数据报；
（2）为ARP模块发送ARP请求和接收ARP应答；
（3）为RARP发送RARP请求和接收RARP应答。
TCP/IP支持多种不同的链路层协议取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路
```

## 以太网链路层协议（多个连接在一起）
```
以太网和IEEE 802封装
1、以太网
是当今TCP/IP采用的主要的局域网技术，速率为10Mb/s，地址为48bit，
2、IEEE 802
802.3针对整个CSMA/CD网络，802.4针对令牌总线网络， 802.5针对令牌环网络
[IEEE 802.2/802.3（RFC 1042）和以太网的封装格式（RFC 894）](../picture/11.png)
```

## 两个串行接口链路层协议（点对点连接，所以没有以太网的头部）
```
（1）SLIP和CSLIP
（2）PPP
点对点链路链接不用ARP协议
```

## 环回接口
```
允许运行在同一台主机上的客户程序和服务器程序通过TCP/IP进行通信，P地址127.0.0.1分配给这个接口，并命名为localhost。一个传给环回接口的IP数据报不能在任何网络上出现。
[环回接口处理IP数据报的过程](../picture/12.png)
```

## 以太网帧
```
| Mac首部 | IP首部 | TCP首部 | HTTP首部 | HTML数据 |
<------------------以太网帧----------------------->
          <--------------以太网帧的净荷------------>
                  <---------ip净荷---------------->
                        <--------tcp净荷---------->
```

## MTU
```
```

# IP协议
## IP首部
```
+--------+-------------+-------------+-------------------------+
| 4位版本 | 4位首部长度 | 8位服务类型  |      16位总长度          |
+--------+-------------+-------------+----------+--------------+
|              16位标识符             |  3位标志 |  13位片偏移   |
+------------------------------------+----------+--------------+
|   8位生存时间(TTL) 8位协议          |     16位首部检验和        |
+------------------------------------+ ------------------------+
|                          32位源ip地址                         |
+--------------------------------------------------------------+
|                         32位目的ip地址                        |
+--------------------------------------------------------------+
|                          选项（如果有）                       |
+--------------------------------------------------------------+
|                              数据                            |
+--------------------------------------------------------------+

> 4位版本号：IPv4
> 首部长度：首部占32bit字的数目,例如5表示5*32=20byte（所以首部肯定为32的整数倍）
> 8位服务类型（TOS）:包括一个3bit的优先权子字段（现在已被忽略），4 bit的TOS子字段和1bit未用位但必须置0,4bit中只能置其中1bit。如果所有4 bit均为0，那么就意味着是一般服务。4bit分别代表最小时延、最大吞吐量、最高可靠性和最小费用
> 16位总长度，整个IP数据报的长度，以字节为单位，最长可达65535字节，但是大多数的链路层都会对它进行分片
> 16位标识，每发送一份报文它的值就会加1
> 3位标识，13位片偏移
> 8位生存时间（TTL）,一旦经过一个处理它的路由器，它的值就减去1。当该字段的值为0时，数据报就被丢弃
> 8位协议，指的是TCP、UDP、ICMP、IGMP
> 16位首部检验和，首部每个16位进行反码求和，结果存在检验和字段中。当收到ip数据报时，对首部每个16位进行反码求和（包含了检验和字段），结果应该为1（由于路由器经常只修改TTL字段（减1），因此当路由器转发一份报文时可以增加它的检验和，而不需要对IP整个首部进行重新计算）
> 32位源ip地址
> 32位目的ip地址
> 附加项字段，路径路由ip等


```

## IP路由选择
```
IP层在内存中有一个路由表，当收到一份数据报时，先检查ip是否为本机ip地址之一或广播地址，
如果是按照ip首部制指定的协议进行处理，不是就进行转发（路由选择）
路由表包含：
（1）目标IP地址：完整的主机地址或者一个网络地址
（2）下一站路由IP地址：
（3）标志：目的ip是网络还是主机地址
路由选择：
（1）能与目的IP完全匹配的表目，发送指定的下一站路由或网路接口
（2）能与目的IP网络号匹配的表目，发送指定的下一站路由或网路接口
（3）发送默认表目
```

## 子网寻址（子网掩码）
```
//结构
     网络号    子网号    主机号

//子网掩码
     作用是多少比特用于子网号及多少比特用于主机号

//在主机上设置子网掩码的作用只有一个，就是判断将要连接的ip地址和主机是否处于一个子网，如果是，则只经过数据链路层，直接发送到ip地址，而不经过路由，否则将数据包发送到路由。

//掩码是一个32bit的值，其中值为1的比特留给网络号和子网号，为0的比特留给主机号。
两种不同类型
B类:11111111 11111111 11111111    00000000
         网络号16位     子网号      主机号
    11111111 11111111 11111111 11 000000
         网络号16位     子网号      主机号
```

## 相关命令
```
//ipconfig

//netstat
     提供系统上的接口信息
```



# ARP和RARP协议
1、ARP
```
//概念
     ARP协议是地址解析协议（Address Resolution Protocol）是通过解析IP地址得到MAC地址的，是一个在网络协议包中极其重要的网络传输协议，它与网卡有着极其密切的关系

     通常网卡仅接收目的地址为网卡物理地址或广播地址的帧

     ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播。目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了

//命令
     检查arp高速缓存中Ip地址到硬件地址之间的映射记录：arp -a

//交换机与路由器
     交换机主要工作在数据链路层（第二层），交换机转发所依据的对象时：MAC地址。（物理地址）
     路由器工作在网络层（第三层）。路由转发所依据的对象是：IP地址。（网络地址）
     所以需要ARP协议，需要目的IP地址的MAC地址

//发送过程
     我的电脑 ------------> 网关 -------------> 服务器
               网关的MAC          服务器的MAC
     注意：点对点链路不涉及ARP协议

//免费ARP
     一种ARP特性，它是指主机发送ARP查找自己的IP地址。通常，它发生在系统引导期间进行接口配置的时候     
     主要用于检测网络中IP地址是否冲突，它是一种功能而非协议。向自己所在网络请求自己的MAC地址，当网络中如果有其他主机使用了与自己相同的IP地址，他就会给主机一个ARP回复，此时如果发免费ARP的主机收到了回复就证明自己所用的IP地址有冲突，如果没有收到回复则说明没有IP地址冲突。

```

2、RARP
```
//概念
     ARP是实现IP到MAC地址的映射，而RARP是实现MAC到IP地址的映射。

```

# UDP
```
(1) 首部
     +------------------------------------------------------------+----------
     |                         32位源IP地址                        |
     +------------------------------------------------------------+ 
     |                         32位目标IP地址                      | UDP伪首部 
     +---+-------------------------+------------------------------+
     | 0 |        8位协议(17)       |          16位UDP长度         |
     +---+-------------------------+------------------------------+----------
     |        16位源端口号          |         16位目标端口号        |
     +-----------------------------+------------------------------+ UDP首部
     |         16位UDP长度          |         16位UDP检验和        |
     +-----------------------------+------------------------------+----------
     |                            数据                            |
     +                  +-----------------------------------------+
     |                  |              填充字节                    |  
     +------------------+-----------------------------------------+
     
     UDP伪首部：和TCP段都包含一个12字节长的伪首部，为了为了计算检验和而设置的。其目的是让UDP两次检查数据是否已经正确到达目的地（例如， IP没有接受地址不是本主机的数据报，以及IP没有把应传给另一高层的数据报传给UDP）
     UDP首部

(2) UDP检验
     UDP检验和覆盖UDP首部和UDP数据
     检验方法与ip类似（16 bit字的二进制反码和）。因为UDP数据报的长度可以为奇数字节，在最后增加填充字节0
     发送方先对UDP检验和的16位全至为0，然后对其进行反码求和，结果写道UDP检验和处。接收方以16位为单位对所有进行加和，结果应为0XFFFF，如果有错就直接丢弃，不报错
     
```

# TCP
0、参考
```
https://coolshell.cn/articles/11564.html

```

1、首部
```
+----------------------------------------------------------+--------------------------------------------------+
|                          16位源端口号                     |                  16位目的端口号                   |
+----------------------------------------------------------+--------------------------------------------------+
|                                                      32位序列号                                              |
+-------------------------------------------------------------------------------------------------------------+
|                                                     32位确认序号                                             |
+------------+---------+-----+-----+------+-----+-----+------+------------------------------------------------+
| 4位首部长度 | 保留6位 | URG | ACK | PSH  | RST | SYN |  FIN  |          16位窗口大小（最大65535字节）          |
+------------+---------+-----+-----+------+-----+-----+------+------------------------------------------------+
|                           16位检验和                        |                  16位紧急指针                   |
+------------------------------------------------------------+------------------------------------------------+
|                                                        选项                                                 |
+-------------------------------------------------------------------------------------------------------------+
|                                                        数据                                                 |
+-------------------------------------------------------------------------------------------------------------+
TCP首部不计任选字段，它通常是20个字节。

URG 表示紧急指针有效。
ACK 确认序号有效。
PSH 接收方应该尽快将这个报文段交给应用层。
RST 重建连接。
SYN 同步序号用来发起一个连接。
FIN 发端完成发送任务。     
紧急指针 是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号
最常见的可选字段是最长报文大小，又称为MSS (Maximum Segment Size)。

```

2、tcp连接与终止
```
(1) tcpdump
     标识 3字符缩写 描述
     S    SYN      同步序号
     F    FIN      发送方完成数据发送
     R    RST      复位连接
     P    PSH      尽可能快地将数据送往接收进程
     .             以上四个标志比特均置0
     1) TCP连接建立与终止的tcpdump（示例）
          > s 1415531521:1415531521(0) win 4096 <mss 1024>
          表示分组的序号是1415531521，而报文段中数据字节数为0，窗口默认大小为4096。注意：显示这个字段需要两个条件: 报文段中至少包含一个数据字节；或者SYN、FIN或RST被设置为1时才显示
          > s 1415531521:1415531521(0) ack 1415531522 win 4096 <mss 1024>
          字段ack 1415531522 表示确认序号。它只有在首部中的ACK标志比特被设置1时才显示。

(2) 连接协议(3次握手)
     1) 请求端（通常称为客户）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN，在这个例子中为1415531521）。这个SYN段为报文段1。
     2) 服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。
     3) 客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。
     注意：初始序号ISN随时间而变化，因此每个连接都将具有不同的ISN
     client                                       server
                SYN 1415531521:1415531521(0)（客户端的初始序列号：1415531521）
     报文段1 ------------------------------------>  
                     <mss 1024>

                SYN 1823083521:1823083521(0)（服务端的初始序列号：1823083521）
            <------------------------------------ 报文段2
                ACK 1415531522, <mss 1024>
                
     报文段3 ------------------------------------>
                ACK 1823083522

(3) 终止连接(4次握手)

     client                                       server
                FIN 1415531522:1415531522(0)（客户端的FIN初始序列号：1415531521 + 1）
     报文段1 ------------------------------------>  
                ACK 1823083522     

            <------------------------------------ 报文段2
                ACK 1415531523

                FIN 1823083522:1823083522(0)（服务端的FIN初始序列号：1823083521 + 1）
            <------------------------------------ 报文段3
                ACK 1415531523    

     报文段4 ------------------------------------>
                ACK 1823083523
     
(4) 超时
     IP数据报内的服务类型（TOS）字段，Telnet客户进程将这个字段设置为最小时延。

(5) TCP的半关闭
     TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

     client                                        server
                             FIN
     shutdown         --------------------------> 向应用进程交付EOF       
                      <-------------------------
                           FIN的ACK

                            data
     应用进程read      <------------------------- 应用进程write
                      ------------------------->   
                           data的ACK

                             FIN
     向应用进程交付EOF <------------------------- 应用进程close
                      ------------------------->           
                            FIN的ACK

(6) 状态迁移
     client状态                                           server状态
                                                          socket、bind、listen
                                                          LISTEN(被动打开) 
                                                          accept(阻塞)
     connect(阻塞)       ---------SYN j--------->        
     SYN_SEND                                             SYN_RCVD
                        <---SYN k, ACK j+1----- 
     ESTABLISHED
     connect(返回)       -------ACK k+1--------->             
                                                          ESTABLISHED                             
                                                          accept(返回)   
                                                          


     close               --------FIN m--------->              
     FIN_WAIT_1                                           CLOSE_WAIT
                         <--------ACK m+1-------          read返回0
     FIN_WAIT_2
                         <--------FIN n---------          close
                                                          LAST_ACK                    
                         --------ACK n+1------->          CLOSED       
     TIME_WAIT
         | 等待2MSL           
     CLOSED
     
(7) MSL和time_wait(2MSL)
     msl是报文最大寿命时间，可为30s，1min或2min。注意区分ip的TTL。
     time-wait开始的时间为tcp四次挥手中主动关闭连接方发送完最后一次挥手，从TIME_WAIT状态到CLOSED状态有一个超时设置，这个超时设置是2MSL
     原因1：为了保证客户端发送的最后一个ack报文段能够到达服务器。因为这最后一个ack确认包可能会丢失，然后服务器就会超时重传第三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报(此处应该是客户端收到一个非法的报文段，而返回一个RST的数据报，表明拒绝此次通信，然后双方就产生异常，而不是收不到。)，那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源。当网络中存在大量的timewait状态，那么服务器的压力可想而知。
     原因2：在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样下一次新的连接中就肯定不会出现旧连接的报文段了。也就是防止已经失效的连接请求报文段出现在本次连接中。如果没有的话就可能这样：这次连接一挥手完马上就结束了，没有timewait。这次连接中有个迷失在网络中的syn包，然后下次连接又马上开始，下个连接发送syn包，迷失的syn包忽然又到达了对面，所以对面可能同时收到或者不同时间收到请求连接的syn包，然后就出现问题了。

(8) 复位报文段(RST)
     TCP首部中的RST比特是用于“复位”的。当发往基准的连接出现错误，TCP都会发出一个复位报文段。TCP在下列三种情况下产生RST复位报文段。
     1) 到不存在的端口的连接请求
          产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在监听。对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息；而TCP则使用复位。
     2) 异常终止一个连接
          终止一个连接的正常方式是一方发送FIN，这也称为有序释放，因为在所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。但也有可能发送一个复位报文段而不是FIN来中途释放一个连接，这也称为异常释放。异常终止一个连接对应用程序来说有两个优点：（1）丢弃任何待发数据并立即发送复位报文段；（2）RST的接收方会区分另一端执行的是异常关闭还是正常关闭。
     3) 检测半关闭连接
          如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开的。任何一端的主机异常都可能导致发生这种情况。只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。下面介绍一种建立半打开连接的情形。在bsdi上运行Telnet客户程序，通过它和svr4上的丢弃服务器建立连接。接着断开服务器主机与以太网的电缆，并重启服务器主机。这可以模拟服务器主机出现异常（在重启服务器之前断开以太网电缆是为了防止它向打开的连接发送FIN，某些TCP在关机时会这么做）。服务器主机重启后，我们重新接上电缆，并从客户向服务器发送一行字符。由于服务器的TCP已经重新启动，它将丢失复位前连接的所有信息，因此它不知道数据报文段中提到的连接。TCP处理的原则是接收方以复位作为应答。

(9) 同时打开、同时关闭
     迁移状态与普通的不一样

(10) 呼入连接请求队列
     当到达多个连接请求时，可能由于服务器正在处理其他进程，或服务进程正在处理其他事务，导致没法立即接收新的连接请求。TCP协议是如何处理这些呼入的连接请求？
     关键字：连接队列、缓冲队列
     1) 服务端有一个固定长度的连接队列（应用层可以指定最大长度 0~5），该队列中的连接已被TCP接受（即三次握手已经完成），但还没有被应用层所接受。TCP接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列中移出。
     2) 对于新的连接请求，如果连接队列中还有空间，则进行三次握手完成连接的建立。
     3) 应用层只有在三次握手中的第三个报文段收到后才会知道这个新连接时。客户进程的主动打开成功但服务器的应用层还不知道这个新的连接时，它可能会认为服务器进程已经准备好接收数据了（如果发生这种情况，服务器的TCP仅将接收的数据放入缓冲队列)。
     4) 如果对于新的连接请求，连接队列中已没有空间, TCP将不理会收到的SYN。也不发回任何报文段（即不发回R S T）。如果应用层不能及时接受已被TCP接受的连接，这些连接可能占满整个连接队列，客户的主动打开最终将超时。

```
<img src="../../picture/17.jpg" width="400px" height="600px" />

3、TCP交互数据流
```
(1) 交互式输入
     client                        server
     按键   ----数据字节------>     接收字节，然后进行时延的确认推迟发送ACK
            <---数据字节确认---    
            <---回显数据字节---     回显     
     显示   ------回显确认---->         
     一般可以将报文段2和3进行合并

(2) 为了提高这类数据的发送效率和降低网络负担，TCP采用了两种策略：捎带ACK(时延的确认)和Nagle算法。

(3) 时延的确认
     通常TCP在接收到数据时并不立即发送ACK；它会推迟发送（时延为200ms），以便将ACK与需要沿该方向发送的数据一起发送。

(4) Nagle算法
     为了减少广域网的小分组数目，从而减小网络拥塞的出现。其中小分组的定义是小于MSS的任何分组。
     该算法要求一个tcp连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组。
     使用TCP套接字选项TCP_NODELAY可以关闭套接字选项
```

4、TCP的成块数据流
```
// 对于一些数据吞吐量要求较高的应用，总是希望每次发送尽可能多的数据到主机，对于这类应用，TCP使用滑动窗口协议，该协议允许发送方在停止发送前和等待确认前可以连续发送多个分组，因此可以加速数据的传输。  

(1)  



(2) 滑动窗口协议
     TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区。
     1) 概念
          > TCP滑动窗口分为接受窗口，发送窗口
               滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的
          > 合拢、收缩、张开
               |-> 合拢    收缩 <-|-> 张开
               |-------窗口-------|
               合拢：发生在数据被发送和确认时
               张开：接收进程读取已经确认的数据并释放了TCP的接收缓存时
          > ACK、WIN
               ack：期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据
               win：当前的窗口大小m，表示发送方还可以发送多少数据(y=m-(x-n),x:当前已经发送的字节序号)
          > 窗口
               * 发送端
                                  LastByteSent(已发送的数据，但会没有收到ack的位置)
                  win start        |            win end  
                  --+--------------+-------------+
               [1]  |     [2]      |    [3]      |.....    
                  --+--------------+-------------+
                    |                            |  
               LastByteAcked(被接收端Ack过的位置) LastByteWriten
                    [1]: 已发送并收到ack的数据（不再发送窗口和发送缓冲区之内）
                    [2]: 已发送、但未收到ack的数据（位于发送窗口之中）
                    [3]: 未发送、上层应用正在写的区域（位于发送窗口之中）

               * 接收端
                                                  NextByteExpected(收到连续包的最后位置)
                    win start                       |                                     win end
                  --+-------------------------------+------------------------+------------+                     
               [1]  |             [2]               |          [3]           |     [4]    |....
                  --+-------------------------------+------------------------+------------+
                    |                                                        |
                  LastByteRead(被接收端Ack过的位置)                        LastByteRcvd(收到包的最后一个位置)
                    [1]: 已接收的数据，已被读取（窗口外）
                    [2]: 已接收的连续数据(已发ack),待应用层读取的数据（窗口内）
                    [3]: 已接收到一些数据，有些还未到达，数据空白区（窗口内）
                    [4]: 未收到数据的区域，反馈给发送端的可写的窗口大小：MaxRcvBuffer – LastByteRcvd – 1
          > Zero Window
               当接收方返回win 0给客户端，发送方不会继续发送数据，但是会发送ZWP(Zero Window Probe)包给接受方服务端，让接收方来ack他的Window尺寸，一般这个值会设置成3次，每次大约30-60秒。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。

(3) TCP的拥塞处理
     


```



滑动窗口的滑动是以字节为单位的，发送方A和接收方B在TCP三次握手的前两次握手时协商好了发送窗口和接受窗口的大小，发送方A根据B发送来的确认连接报文中标明的窗口的大小，来确定收到确认前的最大发送数据量，如果A接收到的B发来的确认报文中标明的窗口大小为0，则停止发送数据，直到收到不为0的确认报文，再继续发送。发送窗口表示在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去，凡是已发送过的数据，在没有收到确认前都要暂时保留，以便超时重传时使用。

    需要注意的一点是：使用TCP滑动窗口协议时，接收方不必确认每一个收到的分组，在TCP中，ACK确认是累积的，可以在接收到几个序号连续的报文段后只发送一个ACK确认报文，但累积等待的时间最长不能超过0.5秒，以防止发送端超时重传。

    另外，要注意滑动窗口的三种变化：

    1、窗口合拢。窗口左边沿向右边沿靠近，这种情况发生在数据被发送后收到确认时；

    2、窗口张开。窗口右边沿向右移动，说明允许发送更多的数据，这种情况发生在另一端的接收进程从TCP接收缓存中读取了已经确认的数据时；

    3、窗口收缩。窗口右边沿向左移动，一般很少发生，RFC也强烈不建议这么做，因为很可能会产生一些错误，比如一些数据已经发送出去了，又要收缩窗口，不让发送这些数据。

    另外，窗口的左边沿是肯定不可能左移的，如果接收到一个指示窗口左边沿向左移动的ACK，则它被认为是一个重复ACK，并被丢弃。

    总结以下几点：

    1、发送方不必发送一个全窗口大小的数据，一次发送一部分即可。

    2、窗口的大小可以减小，但是窗口的右边沿却不能向左移动。

    3、接收方在发送一个ACK前不必等待窗口被填满。

    4、窗口的大小是相对于确认序号的，收到确认后的窗口的左边沿从确认序号开始。













## TCP章节
### 





