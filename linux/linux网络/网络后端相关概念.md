jquery发送数据，nodejs接收数据
get post
post有四种提交方式
post请求分两部分，header 和 body
1、application/x-www-form-urlencoded
最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，就会以这种方式提交
POST http://www.example.com HTTP/1.1
Content-Type: application/x-www-form-urlencoded;charset=utf-8
title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3
jquery提交实例：
text传递：
data: $("#form").serialize() a=1&b=2&c=3   
dataType = "text"

json传递：


表单转换：$("#form").serialize() a=1&b=2&c=3   
$("#form").serializeArray() [
                     {name:'a',value:'1'},
                     {name:'b',value:'2'},
                     {name:'c',value:'3'},
        						]
$('botton').click(function(){


});



nodejs接受json
ajax{	//客户端发送

}
nodejs发送json
var data={user:'malx',age:12,msg:'aaaaa'};
res.end(JSON.stringify(data));



//openssl
加密相当于我自己生成一把锁和一把钥匙，然后把锁发给你，你用我的锁把想发给我的东西锁上再发给我，我收到之后用钥匙打开锁。天下人都能拿到我的锁，但只有我有这把锁的钥匙。这个例子中，钥匙相当于私钥，锁相当于公钥。数字加密涉及三个过程：
    - 生成一对公钥和私钥
    - 加密：公钥+明文->密文
    - 解密：私钥+密文->明文


签名相当于我自己生成一把锁和一把钥匙，然后把我想发布的内容用我的锁锁起来形成一个签名，把内容和签名一起发布，并且告诉大家我的钥匙是什么。人们可以拿到钥匙来打开签名里的内容来验证是不是跟发布的内容一致。天下人都能拿到钥匙来验证签名与内容的一致性，但只有我有签名的锁。这个例子中，钥匙相当于公钥，锁相当于私钥。数字签名涉及三个过程：
    - 生成一对公钥和私钥
    - 签名：私钥+内容->签名
    - 验证：公钥+签名+内容->内容有没有改变

 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。

https改变了通信方式，它由以前的http—–>tcp，改为http——>SSL—–>tcp；https采用了共享密钥加密+公开密钥加密的方式
https连接过程
客户端发送请求到服务器端
服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在
证书由权威机构颁发（公钥+申请者与颁发者的相关信息+签名），并且对公开密钥做了签名（见上面签名），客户端
客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端

服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端
客户端使用共享密钥解密数据
SSL加密建立………



---
#### 分层协议
```
(1)应用层
HTTP（Hypertext Transfer Protocol 超文本传输协议，显示网页）
DNS（Domain Name System）
FTP（File Transfer Protocol）
SFTP（SSH File Transfer Protocol，和FTP不一样）
SCP（Secure copy，based on SSH）
SSH （Secure Shell）

(2)通信层
TCP（Transmission Control Protocol 三次握手传输协议）
UDP

(3)网络层
IP（Internet Protocol）
ICMP（Internet Control Message Protocol，主要用于路由发送错误报告）

(4)链接层：
MAC（media access control）
```

---
#### FTP
```
FTP是在TCP/IP网络和INTERNET上最早使用的协议之一，它属于网络协议组的应用层。
FTP客户机可以给服务器发出命令来下载文件，上载文件，创建或改变服务器上的目录。
相比于HTTP，FTP协议要复杂得多。复杂的原因，是因为FTP协议要用到两个TCP连接，一个是命令链路，
用来在FTP客户端与服务器之间传递命令；另一个是数据链路，用来上传或下载数据。FTP是基于TCP协议的
```

---
#### SFTP
```
SFTP与 FTP有着几乎一样的语法和功能。SFTP为SSH的一部份，是一种传输文件到服务器的安全方式。
```

---
#### scp
```
进行远程文件复制的，并且整个复制过程是加密的。数据传输使用ssh，并且和使用和ssh相同的认证方式，提供相同的安全保证
```

---
#### ftp sftp scp比较
```
FTP 基于TCP来传输文件，明文传输用户信息和数据。
SFTP 基于SSH来加密传输文件，可靠性高，可断点续传。
SCP 是基于SSH来加密拷贝文件，但要知道详细目录，不可断点续传。
http://www.cnblogs.com/zihanxing/articles/5665383.html

ftp包含两个端口，控制和数据传输、21和20端口
sftp是在ssh的一部分，本身没有单独的守护进程，必须借用ssh完成相关操作，所以更改sftp端口，需要重新开一个ssh进程，然后修改ssh的控制端口和sftp的数据传输端口

```

---
#### http与https的port
端口号 https默认端口 443， http默认的端口号是80

---
#### 跨域访问

---
#### rpc vs websocket

---
#### favicon.ico
浏览器的两次http请求

---
#### 长连接与短链接
TCP协议的长连接和短连接
```
(1)长连接
数据传输完成了保持TCP连接不断开(不发RST包、不四次握手),等待在同域名下继续用这个通道传输数据；相反的就是短连接。
Connection: keep-alive
keep-alive: timeout=20  //表示TCP通道可以保持20s

```

---
#### FIN与RST

---
#### TCP报文

---
#### Cookie、session和localStorage、以及sessionStorage
```
cookie localStorage sessionStorage属于浏览器存储
localStorage生命周期是永久
sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过sessionStorage存储的数据也就被清空了
注意：服务器无法直接获取localStorage、以及sessionStorage
```

---
#### cookie与签名cookie
```
```

---
#### 浏览器缓存
ETag、Cache-Control

---
#### X-Forwarded-For
X-Forwarded-For: client1, proxy1, proxy2, proxy3

---
#### X-Powered-By
隐藏响应的server

---
#### X-Requested-With 
```
如果 requestedWith 为 null，则为同步请求。
如果 requestedWith 为 XMLHttpRequest 则为 Ajax 请求。
```

---
#### SMTP POP3 IMAP
```
简单地说，SMTP管‘发’，POP3/IMAP管‘收’。
POP是负责邮件程序和邮件服务器收信的通讯协定，SMTP则是负责邮件服务器与邮件服务器之间的寄信的通讯协定
SMTP: 发送方的邮件服务器发送报文到接收方邮件服务器.
POP3: 简单的邮件访问协议,单向的,本地对邮件的操作不会同步到邮件服务器,用来从邮件服务器取得邮件.
IMAP: 比POP3更复杂的邮件访问协议，是双向的，对保存到本地的邮件的操作会同步到邮件服务器。
```

---
#### go 与 epoll
当一个goroutine读取/写入网络socket时候阻塞，系统会自动使用epoll/kqueue/iocp 来处理，这个对用户是全透明的。

```
epoll -> go server
https://blog.csdn.net/yxw2014/article/details/79375384
```

---
#### 三次握手
```
服务器端在调用listen之后，内核会建立两个队列，SYN队列和ACCEPT队列，其中ACCPET队列的长度由backlog指定。
服务器端在调用accpet之后，将阻塞，等待ACCPT队列有元素。
客户端在调用connect之后，将开始发起SYN请求，请求与服务器建立连接，此时称为第一次握手。
服务器端在接受到SYN请求之后，把请求方放入SYN队列中，并给客户端回复一个确认帧ACK，此帧还会携带一个请求与客户端建立连接的请求标志，也就是SYN，这称为第二次握手
客户端收到SYN+ACK帧后，connect返回，并发送确认建立连接帧ACK给服务器端。这称为第三次握手
服务器端收到ACK帧后，会把请求方从SYN队列中移出，放至ACCEPT队列中，而accept函数也等到了自己的资源，从阻塞中唤醒，从ACCEPT队列中取出请求方，重新建立一个新的sockfd，并返回。
```

---
### 服务器的核心功能 
功能模块:
配置文件解析
数据库

中间件：
parser  
compress  
cookie
session
安全（CORS、防止多次递交表单、session劫持防范、CSRF、XSS、SQL注入、加密解密，反爬机制，防止暴力破解账号密码）
static
logger

增加的功能:
websocket
RPC

---
### 浏览器存储持久化 
```
sessionStorage.setItem("annotation_url","<%=annotation_url%>");
```

---
### http代理head知识
```
//代理路径
X-Forwarded-For: client, proxy1, proxy2
只能作为参考

//代理认证（客户端与代理服务器之间的认证,）
Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
用户名和密码通过:拼接后进行base64编码而成(QWxhZGRpbjpvcGVuIHNlc2FtZQ==)

//remoteAddress
//例如：client->IP1->IP2->IP3->service
//服务器收到的头
RemoteAddress: IP3
X-Forwarded-For: client,IP0, IP1, IP2
注意RemoteAddress无法伪造，x-Forwarded-For可以伪造

//浏览器启用正向代理后，会对 HTTP 请求报文做一些修改
//浏览器代理前->代理后的改变
GET / HTTP/1.1
Host: www.example.com
Connection: keep-alive
 
GET http://www.example.com/ HTTP/1.1
Host: www.example.com
Proxy-Connection: keep-alive
注意：
    有了代理就麻烦了，代理不知道GET / HTTP /1.0  这个请求发给哪个主机，所以HTTP 1.0 又要求浏览器给代理发送的时候必须发送完整的路径名称
    GET http://www.example.com/ HTTP/1.0
    HTTP 1.1 规定了必须包含Host主机名这个字段。所以 HTTP 1.1 可以是
    GET / HTTP/1.1
    Host: www.example.com
    但是由于不清楚代理是1.0 还是1.1的 也许代理不认识Host这个头。 所以http 1.1 发给代理的最后格式就变为
    GET http://www.example.com/ HTTP/1.1
    Host: www.example.com

//代码    
var http = require('http');
var net = require('net');
var url = require('url');
function request(cReq, cRes) {
    var u = url.parse(cReq.url);
    var options = {
        hostname : u.hostname, 
        port     : u.port || 80,
        path     : u.path,       
        method     : cReq.method,
        headers     : cReq.headers
    };
    var pReq = http.request(options, function(pRes) {
        cRes.writeHead(pRes.statusCode, pRes.headers);
        pRes.pipe(cRes);
    }).on('error', function(e) {
        cRes.end();
    });
    cReq.pipe(pReq);
}
http.createServer().on('request', request).listen(8888, '0.0.0.0');
```

---
### https代理（隧道代理）
```
//普通的http代理是不能用作https代理的，没有证书无法与服务器建立TLS链接
//假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。
//代码
var http = require('http');
var net = require('net');
var url = require('url');
function connect(cReq, cSock) {
    var u = url.parse('http://' + cReq.url);
    var pSock = net.connect(u.port, u.hostname, function() {
        cSock.write('HTTP/1.1 200 Connection Established\r\n\r\n');
        pSock.pipe(cSock);
    }).on('error', function(e) {
        cSock.end();
    });

    cSock.pipe(pSock);
}
http.createServer().on('connect', connect).listen(8888, '0.0.0.0');

```


---
### 短连接与长连接
```
短连接：短连接是指服务端与客户端每次完成通讯后，就断开连接套接字Socket ConnectSocket的连接，同时每次需要服务端与客户端产生通讯的时候，都要重新创建连接套接字Socket ConnectSocket，最典型的短连接应该就是HTTP了吧（当然从HTTP/1.1起，HTTP默认使用长连接）
长连接：用于对于客户端来说，其只需要一个连接套接字Socket ConnectSocket就能完成与服务端所有的通讯，因此对于长连接来说，客户端只需在最开始创建一个连接套接字Socket ConnectSocket，便可以和服务端反复通讯多次。而当一个连接套接字Socket ConnectSocket长时间存在，其便会出现两个问题：1、当Socket ConnectSocket的连接如果被中断后，我们再去使用这个Socket ConnectSocket进行通讯时，其便会出错；2、如果服务端不断地接收客户端的连接并创建相应的连接套接字Socket ConnectSocket，却又不去关闭已经失效的Socket ConnectSocket，那么服务端迟早将会挂掉。由于会出现以上这两个问题，为此便引申出了KeepAlive机制。
KeepAlive机制：简单地来讲就是让一台主机每隔一段时间不停地向另一台远程主机发送连接请求（心跳包），以确认对方是否仍处于连接状态，如果发现对方长时间不应答，便关闭与对方连接。理论上来说服务端和客户端都可以向对方发送心跳包，但一般来说都是由客户端向服务端发送心跳包。在TCP中，KeepAlive机制默认是如果对方2小时不应答，则会断开连接，但是由于2小时时间过长，因此一般我们都要重写该机制。
```

---
### 代理协议(加密)
```
//代理协议
HTTPS，SOCKS5-TLS 和 shadowsocks

//代理级数
(1) 透明代理
在透明代理中，代理服务器将客户端的信息转发至目标访问对象，并没有完全隐藏客户端真实的身份。即服务器知道客户端使用了代理IP，并且知道客户端的真实IP地址。
(2) 普通匿名代理
在普通匿名代理中，代理服务器用自己的IP代替了客户端的真实IP，但是告诉了目标访问对象这是代理访问。
(3) 欺骗匿名代理
在欺骗匿名代理中，目标访问对象同样可以察觉客户端使用代理访问，但是代理服务器会用一个随机的IP代替客户端真实的IP。
(4) 高匿代理
在高匿代理中，代理服务器良好地伪装了客户端，不但用一个随机的IP代替了客户端的IP，也隐藏了代理信息，服务器不会察觉到客户端是通过代理实现访问的，即用户仿佛就是直接使用代理服务器作为自己的客户端。
通常，服务器通过获取HTTPRequest的头部信息的相关字段来判断客户端是否使用了代理。该字段包括REMOTE_ADDR、HTTP_VIA、HTTP_X_FORWARDED_FOR等。

//识别ip代理
对于透明代理和普通匿名代理，代理服务器一般会在HTTP头上加入一些信息，可以通过判断HTTP头来校验是否是通过代理访问。对于高匿代理，代理服务器会直接转发请求，不会有任何附加信息，这种情况下，只能通过IP反查来判断是否是代理服务器（你得到当前访问的IP后，反向发送请求回这个IP对各端口进行扫描来判断是否是代理；当然，也有很多第三方的商用反网络欺诈服务提供商，你可以在他们的数据库中查询当前访问的IP是否是一个他们已知的代理服务器）

//tcp代理（socks5和shadowsocks都属于tcp代理）
（1）socks
    浏览器<--->代理服务器<--->饿了么网站
（2）shadowsocks
    浏览器<--->SSlocal<--->SSServer<--->网站
    SSlocal 会将浏览器发来的数据加密，发送给 SSServer ， SSServer 把数据解密后发给网站。

//抗识别
单纯的socks5代理很容易被识别，一般不用。
用shadowsocks吧

```

---
### 内网穿透和隧道
```
这个和上面的代理不一样，代理是客户端用代理服务器进行上网，而内网穿透是通过公网ip服务器与内网ip服务器建立一个隧道，外部访问公网ip，相当于访问内网ip
```

---
### MSS
```
TCP的最大报文段大小
1460Bytes(1500BytesMTU - 20Bytes(IP Header) - 20Bytes(TCP Header))
```

---
### Seq和Win
```

```

---
### 滑动窗口
```
```

--- 
### MTU和ip total length
```

```

--- SYN ACK Seq
```
```

---
### tcp滑动窗口
```

```
---
### 再认跨域
```
之前全理解错了！！！
应该是防止别的url访问本服务器，所以应该在本服务器设置access头

在aaa.com页面中需要跨域访问bbb.com，bbb.com只允许自己的域访问，所以aaa.com连接不通bbb.com.
只有在bbb.com服务端设置access头才能实现aaa.com对bbb.com的访问

``` 

### User-Agent
```

```

---
### CDN
```
//CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络"边缘"，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度
//CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现

用户-->浏览器域名解析库--->cdn域名---->ip地址
     `-> CNAME解析 ----|
         A记录解析
```

---
### 堡垒机
```
当前公司控制内部人员登陆服务器加上的中间层，但是web可以直接访问服务器
例如：直接ssh 10.100.6.13失败必须通过堡垒机（https://10.10.99.146/fort/frame.action）才能访问
但是在10.100.6.13上面开启8000端口，就可以直接网页访问此端口

//按功能分
网关型堡垒机: 堡垒机不提供路由功能,将内外网从网络层隔离开来，处理应用层的数据内容,性能消耗很大
运维审计型堡垒机: 截获运维人员的操作，
//类别分
硬件堡垒机：外形就像个DVD影碟机
软件堡垒机：对现有网络结构存在一定程度的入侵，会改变运维习惯。
云堡垒机：???


外部 -> | -> Nginx -> 交换机 -> 服务器集群

客户端 -> ssh(:22) ❌ -> 服务器集群
    `-----> 堡垒机 ---->  服务器集群
    `--> http :8000 -->  服务器集群

```

---
### golang cookie
```
type Cookie struct {
  Name       string
  Value      string
  Path       string
  Domain     string
  Expires    time.Time
  RawExpires string
  MaxAge     int
  Secure     bool
  HttpOnly   bool   //注意！！！！
  Raw        string
  Unparsed   []string
}
```

---
### session超时
```
后端通过保存session来保持当前连接的状态，设置session超时，当某一session id过期时就会删除它，当再有这个session id访问时，由于此session id不存在了，就需要此用户重新登陆，获得新的session id
```

---
### 路由表
```                                             H(直连)
route -n                                        G(路由)
目的网段         所走网关        掩码             U(有效)
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.161.0   192.168.161.1   255.255.255.0   UG    0      0        0 em1
192.168.161.0   0.0.0.0         255.255.255.0   U     0      0        0 em1
192.168.61.0    0.0.0.0         255.255.255.0   U     0      0        0 em2
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 em1
169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 em2
192.168.0.0     192.168.61.1    255.255.0.0     UG    0      0        0 em2
0.0.0.0         192.168.61.1    0.0.0.0         UG    0      0        0 em2
0.0.0.0         192.168.161.1   0.0.0.0         UG    0      0        0 em1

路由匹配是最长匹配

```

---
### NAT(地址转换技术)
```
https://blog.csdn.net/gui951753/article/details/79593307
私网ip与公网ip的转换

在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。

一般使用私网ip作为局域网内部的主机标识，使用公网ip作为互联网上通信的标识 

//NAT重载
将多个私网ip地址映射到一个公网ip地址(多对一)，NAT网关并不只是进行IP地址的简单替换，当接受到外部请求时还要还原信息，以确保发送给哪一台主机。他把这些信息存放在NAT关联表中。

//缺点
（1）无法实现端对端的ip跟踪
    由于多个私网ip地址映射到一个公网ip地址，所以访问目标服务器，就被认为是一台主机在访问，这会导致严重的后果。比如：服务器限制有限访问，DOS攻击保护
（2）很多应用层协议无法识别（比如ftp协议）

//NAT穿越
从隧道技术可以避免上述错误

//SNAT是source network address translation的缩写即源地址目标转换
//DNAT是destination network address translation的缩写即目标网络地址转换
```

---
### 隧道（Tunnel）
```
隧道有两个IP头，外部IP用于在Internet传输，而内部IP就是局域网IP

//非隧道模式
ip/tcp/http     没有加密的网页
ip/tcp/tls/http 加密的网页
ip/tcp/ftp      ftp下载
ip/udp/dns      域名解析
非隧道模式访问Internet上的资源是非常合适的。但往往不便于访问私有资源。

//隧道模式
https://www.zhihu.com/question/39382183/answer/404245930
比如一台内部ip 10.0.8/24的服务器供内部员工访问，如果外网想要访问，就用隧道技术
(1)IPIP技术
Outside ip/(ip/tcp/smb(协议名)) 
但是这种类型非常不便于穿越NAT(上面的NAT),为了避免由于NAT的差异而造成通信故障，一般不使用IPIP隧道。
(2)UDP隧道
Outside ip/udp/(ip/tcp/smb)
用不同的udp端口来区分不同的用户隧道，注意必须是UDP隧道，而不是TCP隧道
(3)隧道加密
Outside ip/udp/esp/(ip/tcp/smb)
              加密层

通常称 Outside ip/udp/esp/ 为控制连接，称ip/tcp/smb 为用户数据连接
```

---
### linux防火墙（iptables）
```
iptables是Linux内核默认的防火墙，它对出入网络的IP、数据进行检测，操作和屏蔽

（1）iptables在内核空间中的五个位置发生作用：
    内核空间中：从一个网络接口进来，到另一个网络接口去的
    数据包从内核流入用户空间的
    数据包从用户空间流出的
    进入/离开本机的外网接口
    进入/离开本机的内网接口

（2）这五个位置也被称为五个钩子函数（hook functions）,也叫五个规则链。（链）❗
    防火墙的作用就是对经过的报文进行匹配规则，然后执行对应的动作。以下五个叫做关卡，因为每个关卡会有多个rule，就会形成一条链，所以下面五个关卡又叫做五条链
    PREROUTING (路由前) 
    INPUT (数据包流入口)
    FORWARD (转发管卡)
    OUTPUT(数据包出口)
    POSTROUTING（路由后）

（3）我们现在用的比较多个功能有3个：（表）❗
    iptables定义了4个表，每种表对应不同功能
    filter：定义允许或者不允许的
    nat：定义地址转换
    mangle:修改报文原数据、

（4）表和链关系
    注意：下表中的表不代表顺序
    链 PREROUTING    rule1 --> rule2 --> rule3 --> rule4 --> rule5 --> rule6
                    |                 |                   |                |
    表              +-------nat-------+------filter-------+------mangle----+

    filter：在3个链上INPUT ，FORWARD ，OUTPUT
    nat：   在3个链上PREROUTING ，OUTPUT ，POSTROUTING
    mangle：5个链都可以做PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING
```

### Linux系统的数据转发
```
当主机拥有多于一块的网卡时(或者虚拟网络设备)，其中一块收到数据包，根据数据包的目的ip地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包。这通常就是路由器所要实现的功能。
cat /proc/sys/net/ipv4/ip_forward
如果上述文件中的值为0,说明禁止进行IP转发；如果是1,则说明IP转发功能已经打开。
```

### 字符编码
```
（1）ACSII
ACSII最早只有127个字母被编码到计算机里，但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GBK编码，用来把中文编进去。

（2）ANSI（ACSII的扩展）
为了使计算机支持多种语言，不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。

（3）unicode
Unicode编码使用两个字节（0x0000－0xFFFF）来表示一个字符，世界上任何文字和符号都对应于Unicode字符集中的一个二进制代码。
Unicode只是一个符号集, 它只规定了符号的二进制代码, 却没有规定这个二进制代码应该如何存储。

（4）utf-8
UTF-8是Unicode的实现方式之一。UTF-8是一种变长的编码方式，可以使用1~6个字节对Unicode字符集进行编码

（5）编码与存储
GBK、UTF-8是一种编码格式，用来序列化或存储unicode编码的数据的，但是分别是2种不同的格式。

（5）关系
GBK <---> Unicode <---> UTF8 
1）unicode是字符集，ASCII、GB2312、GBK、GB18030既是字符集也是编码方式，UTF-8只是编码方式。
2）中文操作系统默认ansi编码，生成的txt文件默认为ansi编码。
3）国际文档（txt和xml）使用unicode编码是正宗做法；操作系统和浏览器都能够“理解”unicode编码。浏览器“迫于压力”才“理解”utf-8编码。但是，操作系统有时只认unicode编码。
4）Windows记事本有四个编码选项：ANSI、Unicode、Unicode Big Endian和UTF-8。
5）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。
6）
    文件         内存        看到的
    utf8 -----> unicode --> 字符    国际
    gbk  -----> gbk     --> 字符    国内
    gbk  -----> unicode --> 字符    转换
```

### unix域套接字
```
同一台计算机之间的socket通信，unix域套接字很像文件描述符（具现化）。
struct sockaddr_un {
    sa_family    sun_family;    /* AF_UNIX */
    char         sun_path[108];    /* pathname */
};
```